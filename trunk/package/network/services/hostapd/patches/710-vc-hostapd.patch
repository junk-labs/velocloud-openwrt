--- a/src/ap/ieee802_1x.c
+++ b/src/ap/ieee802_1x.c
@@ -14,6 +14,7 @@
 #include "crypto/crypto.h"
 #include "crypto/random.h"
 #include "common/ieee802_11_defs.h"
+#include "common/wpa_ctrl.h"
 #include "radius/radius.h"
 #include "radius/radius_client.h"
 #include "eap_server/eap.h"
@@ -1470,6 +1471,8 @@ ieee802_1x_receive_auth(struct radius_msg *msg, struct radius_msg *req,
 		} else if (session_timeout_set)
 			ap_sta_session_timeout(hapd, sta, session_timeout);
 
+		ap_sta_reset_inactivity_timeout(hapd, sta);
+
 		sm->eap_if->aaaSuccess = TRUE;
 		override_eapReq = 1;
 		ieee802_1x_get_keys(hapd, sta, msg, req, shared_secret,
@@ -1485,6 +1488,21 @@ ieee802_1x_receive_auth(struct radius_msg *msg, struct radius_msg *req,
 				       HOSTAPD_LEVEL_DEBUG,
 				       "Added PMKSA cache entry");
 		}
+
+		char radius_av_buf[1024];
+		int data_len = snprintf(radius_av_buf, 1024, 
+				AP_STA_RAD_ATTR MACSTR, MAC2STR(sta->addr));
+		int rc = radius_msg_copy_attr_tobuf(
+					sm->last_recv_radius, 
+					(u8*)&(radius_av_buf[data_len]),
+				       	1024 - data_len);
+		if (rc < 0) {
+			wpa_printf(MSG_ERROR, 
+					"radius msg copy attr failed");
+		} else if (rc > 0) {
+			wpa_msg_bin(hapd, MSG_INFO, radius_av_buf, data_len+rc);
+		}
+		radius_msg_dump(sm->last_recv_radius);
 		break;
 	case RADIUS_CODE_ACCESS_REJECT:
 		sm->eap_if->aaaFail = TRUE;
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -470,6 +470,13 @@ void ap_sta_session_timeout(struct hostapd_data *hapd, struct sta_info *sta,
 			       hapd, sta);
 }
 
+void ap_sta_reset_inactivity_timeout(struct hostapd_data* hapd, 
+		struct sta_info* sta)
+{
+	eloop_cancel_timeout(ap_handle_timer, hapd, sta);
+	eloop_register_timeout(hapd->conf->ap_max_inactivity, 0,
+			       ap_handle_timer, hapd, sta);
+}
 
 void ap_sta_no_session_timeout(struct hostapd_data *hapd, struct sta_info *sta)
 {
--- a/src/ap/sta_info.h
+++ b/src/ap/sta_info.h
@@ -163,6 +163,8 @@ void ap_sta_session_timeout(struct hostapd_data *hapd, struct sta_info *sta,
 			       struct sta_info *sta);
 void ap_sta_session_warning_timeout(struct hostapd_data *hapd,
 				    struct sta_info *sta, int warning_time);
+void ap_sta_reset_inactivity_timeout(struct hostapd_data* hapd, 
+		struct sta_info* sta);
 struct sta_info * ap_sta_add(struct hostapd_data *hapd, const u8 *addr);
 void ap_sta_disassociate(struct hostapd_data *hapd, struct sta_info *sta,
 			 u16 reason);
--- a/src/common/wpa_ctrl.h
+++ b/src/common/wpa_ctrl.h
@@ -146,6 +146,8 @@ extern "C" {
 #define AP_STA_CONNECTED "AP-STA-CONNECTED "
 #define AP_STA_DISCONNECTED "AP-STA-DISCONNECTED "
 
+#define AP_STA_RAD_ATTR "AP-STA-RAD-ATTR "
+
 #define AP_REJECTED_MAX_STA "AP-REJECTED-MAX-STA "
 #define AP_REJECTED_BLOCKED_STA "AP-REJECTED-BLOCKED-STA "
 
--- a/src/drivers/driver_wired.c
+++ b/src/drivers/driver_wired.c
@@ -165,6 +165,7 @@ static void handle_read(int sock, void *eloop_ctx, void *sock_ctx)
 }
 
 
+/*
 static void handle_dhcp(int sock, void *eloop_ctx, void *sock_ctx)
 {
 	int len;
@@ -179,7 +180,7 @@ static void handle_dhcp(int sock, void *eloop_ctx, void *sock_ctx)
 		return;
 	}
 
-	/* must contain at least dhcp_message->chaddr */
+	// must contain at least dhcp_message->chaddr 
 	if (len < 44) {
 		wpa_printf(MSG_MSGDUMP, "handle_dhcp: too short (%d)", len);
 		return;
@@ -195,6 +196,7 @@ static void handle_dhcp(int sock, void *eloop_ctx, void *sock_ctx)
 	event.new_sta.addr = mac_address;
 	wpa_supplicant_event(eloop_ctx, EVENT_NEW_STA, &event);
 }
+*/
 #endif /* __linux__ */
 
 
@@ -203,8 +205,8 @@ static int wired_init_sockets(struct wpa_driver_wired_data *drv, u8 *own_addr)
 #ifdef __linux__
 	struct ifreq ifr;
 	struct sockaddr_ll addr;
-	struct sockaddr_in addr2;
-	int n = 1;
+	//struct sockaddr_in addr2;
+	//int n = 1;
 
 	drv->sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_PAE));
 	if (drv->sock < 0) {
@@ -258,6 +260,7 @@ static int wired_init_sockets(struct wpa_driver_wired_data *drv, u8 *own_addr)
 	os_memcpy(own_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
 
 	/* setup dhcp listen socket for sta detection */
+	/*
 	if ((drv->dhcp_sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
 		perror("socket call failed for dhcp");
 		return -1;
@@ -298,6 +301,7 @@ static int wired_init_sockets(struct wpa_driver_wired_data *drv, u8 *own_addr)
 		perror("bind");
 		return -1;
 	}
+	*/
 
 	return 0;
 #else /* __linux__ */
@@ -608,6 +612,12 @@ static void wpa_driver_wired_deinit(void *priv)
 	os_free(drv);
 }
 
+static int wpa_driver_wired_get_inact_sec(void* priv, const u8 *addr)
+{
+    // Not supported
+	printf("Inactivity timeout for wired not supported.\n");
+    return -1;
+}
 
 const struct wpa_driver_ops wpa_driver_wired_ops = {
 	.name = "wired",
@@ -620,4 +630,5 @@ const struct wpa_driver_ops wpa_driver_wired_ops = {
 	.get_capa = wpa_driver_wired_get_capa,
 	.init = wpa_driver_wired_init,
 	.deinit = wpa_driver_wired_deinit,
+        .get_inact_sec = wpa_driver_wired_get_inact_sec,
 };
--- a/src/radius/radius.c
+++ b/src/radius/radius.c
@@ -1257,6 +1257,22 @@ radius_msg_add_attr_user_password(struct radius_msg *msg,
 				   buf, buf_len);
 }
 
+int radius_msg_copy_attr_tobuf(struct radius_msg* msg, u8* buf, size_t len)
+{
+	struct radius_attr_hdr *attr = NULL;
+	size_t i, len_copied = 0;
+
+	for (i = 0; i < msg->attr_used; i++) {
+		attr = radius_get_attr_hdr(msg, i);
+		if (!attr || attr->length < sizeof(*attr))
+			return -1;
+		if (len_copied + attr->length > len)
+			break;
+		os_memcpy(buf + len_copied, attr, attr->length);
+		len_copied += attr->length;
+	}
+	return len_copied;
+}
 
 int radius_msg_get_attr(struct radius_msg *msg, u8 type, u8 *buf, size_t len)
 {
--- a/src/radius/radius.h
+++ b/src/radius/radius.h
@@ -238,6 +238,7 @@ struct radius_attr_hdr *
 radius_msg_add_attr_user_password(struct radius_msg *msg,
 				  const u8 *data, size_t data_len,
 				  const u8 *secret, size_t secret_len);
+int radius_msg_copy_attr_tobuf(struct radius_msg* msg, u8* buf, size_t len);
 int radius_msg_get_attr(struct radius_msg *msg, u8 type, u8 *buf, size_t len);
 int radius_msg_get_vlanid(struct radius_msg *msg);
 char * radius_msg_get_tunnel_password(struct radius_msg *msg, int *keylen,
--- a/src/utils/wpa_debug.c
+++ b/src/utils/wpa_debug.c
@@ -647,7 +647,11 @@ void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
 		wpa_msg_cb(ctx, level, buf, len);
 	os_free(buf);
 }
 
+void wpa_msg_bin(void* ctx, int level, char* buf, size_t len)
+{
+	wpa_msg_cb(ctx, level, 0, buf, len);
+}
 #endif /* CONFIG_NO_WPA_MSG */
 
 
--- a/src/utils/wpa_debug.h
+++ b/src/utils/wpa_debug.h
@@ -157,6 +157,7 @@ void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
 #define wpa_msg_ctrl(args...) do { } while (0)
 #define wpa_msg_register_cb(f) do { } while (0)
 #define wpa_msg_register_ifname_cb(f) do { } while (0)
+#define wpa_msg_bin(args...) do { } while (0)
 #else /* CONFIG_NO_WPA_MSG */
 /**
  * wpa_msg - Conditional printf for default target and ctrl_iface monitors
@@ -189,6 +190,8 @@ void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
 void wpa_msg_no_global(void *ctx, int level, const char *fmt, ...)
 PRINTF_FORMAT(3, 4);
 
+void wpa_msg_bin(void* ctx, int level, char* buf, size_t len);
+
 typedef void (*wpa_msg_cb_func)(void *ctx, int level, int global,
 				const char *txt, size_t len);
 
