#!/usr/bin/perl

###############################################################################
#
# package_osp.pl
#
# Copyright (c) 2014 Sage Electronic Engineering. All rights reserved.
# Software License Agreement
#
# THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED
# OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
# Sage Electronic Engineering SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR
# SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
#
##############################################################################
use 5.010;
use strict;            #core
use warnings;          #core
use File::Basename;    #core
use Cwd qw(abs_path);
use lib dirname( abs_path($0) ) . '/perl/lib';    # add the directory "perl/lib" to @inc
use File::Find;
use File::Compare;                                #core
use File::Copy;
use File::Find::Rule;
use File::Spec;
use File::Copy::Recursive qw(fcopy rcopy dircopy fmove rmove dirmove);
use File::Path qw(make_path remove_tree);
use Getopt::Long;
use Cwd;
use Digest::SHA qw(sha256_hex);                   #core
use experimental 'smartmatch';                    # lib - don't print the smartmatch warnings on Perl 5.18 or greater

sub usage {
	print "package_osp.pl [--help|-h] \n";
	print "               [--input=<input dir>]\n";
	print "               [--output=<output dir>]\n";
	print "               [--debug] [--savelog] [--checkpkg] [--sloccount]\n";
#	print "               [--dotconfig=<config file>]\n";
	print "               [--proprietary_code]\n";

	print " --input     SageBIOS main coreboot directory to generate the build from.\n";
	print "             The default is 'pwd'\n";
	print " --output    Directory to output the open source package to.\n";
	print "             The default is \"<input dir>/SageBios_<date_time>\"\n";
	print "             This option is also influenced by SAGE_CRB_NAME - the output\n";
	print "             directory becomes \"<input dir>/<SAGE_CRB_NAME>_osp\".\n";
	print " --debug     Generate debug information\n";
	print "             This flag is also enabled by the environment variable 'SAGE_CRB_DEBUG'\n";
	print " --savelog   Saves the log file from the build when completed successfully.\n";
	print " --checkpkg  Builds the Open Source Package to validate the build and clean scripts.\n";
	print "             This automatically tests for missing files that should have been copied\n";
	print "             into the OSP, and tests for relative paths that are broken in the OSP\n";
	print "             build script.\n";
	print " --sloccount Report on the software lines of code in the OSP.  Requires sloccount to\n";
	print "             be installed on the build system.  The sloccount utility is not included\n";
	print "             with the original BSP sources.\n";
#	print " --dotconfig Name of the coreboot config file, relative to the 'coreboot'\n";
#	print "             directory.  Example: \"--dotconfig=configs/config.generic\"\n";
#	print "             The default is \".config\".\n";
	print " --proprietary_code Enables the inclusion of ALL proprietary code that was\n";
	print "                    included in the CBFS (coreboot file system) directory\n";
	print "                    generated by the BSP build\n";
	exit;
}

#command line options
my $print_debug;                 # generate debug information
my $outputDir;                   # directory to output the package and things to
my $inputDir;                    # SageBIOS main coreboot directory to generate the build from
my $include_proprietary_code;    # flag to set building in the proprietary code
my $save_debug_log;              # preserve the build log at the end of the script
my $dotconfigfile;               # name of the coreboot config file
my $checkpkg;
my $get_sloccount;

# paths
my $sage_home;                   # directory of SAGE_HOME in on the current system
my $orig_cwd = getcwd();         # directory that the script was run in
my $outputlog;                   # name of the logfile
my $package_path;                # gets set to outputDir/coreboot
my $archive_name;                # name of the final archive file
my $extract_path;                # directory where archive file is extracted to
my $archive_test_dir;            # directory used for the archive test

# save all the input used to generate the script.
# pre-initialize it so it doesn't get marked as uninitialized if it's printed
# for a failure before it's filled in.
my ( $sloccount  ) = ( "\n" );
my ( @org_cbfs_files, @new_cbfs_files, @excluded_cbfs_files, @binary_diff_files );
my ( @buildScript, @coreboot_dependency_files, @coreboot_required_files );
my ( @addlFiles, @toollist, @license_files );
my ( @proprietary_files, @proprietary_dirs, @included_proprietary_files );
my $hashline = "##############################################################################\n";
my @debugtext;

my %cbfs_files; # Individual files that are contained in CBFS image
my $escapedInputDir;

packager_main();
exit 0;

###############################################################################
#
# FUNCTION:    set_options
# DESCRIPTION: Parse Command Line Parameters
# if no paramaters are passed, we will create an output directory and
# assume the input directory is cwd (which should be coreboot at that point)

###############################################################################
sub set_options {

	#save the commandline
	my $commandline = $0 . " ";
	$commandline .= join(" ", @ARGV);
	debug("Command Line: $commandline");

	GetOptions(
		"h|help"           => \&usage,
#		"dotconfig=s"      => \$dotconfigfile,
		"debug"            => \$print_debug,
		"output=s"         => \$outputDir,
		"input=s"          => \$inputDir,
		"proprietary_code" => \$include_proprietary_code,
		"savelog"          => \$save_debug_log,
		"checkpkg"         => \$checkpkg,
		"sloccount"        => \$get_sloccount,
	);

	if ( ( !defined $print_debug ) && ( defined $ENV{SAGE_CRB_DEBUG} ) ) {
		$print_debug = $ENV{SAGE_CRB_DEBUG};
	}

	$dotconfigfile  = ".config" unless defined $dotconfigfile;
	$save_debug_log = 0 unless defined $save_debug_log;
	$print_debug    = 0 unless defined $print_debug;
	$checkpkg       = 0 unless defined $checkpkg;
	$get_sloccount  = 0 unless defined $get_sloccount;
}

###############################################################################
#
# FUNCTION:    set_directories
# DESCRIPTION: sets up and verifies the input and output directories
#
###############################################################################
sub set_directories {
	# This string is used to generate an output directory name if one was not
	# provided on the command line or through the environment variables.
	my $releasetype = "_open_source";

	$releasetype = "_proprietary" if ($include_proprietary_code);

	# Set the options from environment unless they were specified on the
	# command line
	unless ( defined $outputDir ) {
		if ( defined $ENV{SAGE_CRB_NAME} ) {
			$outputDir   = "$ENV{SAGE_CRB_NAME}${releasetype}";
		}
	}

	# If the output directory exists, delete it.
	if ( ( defined $outputDir ) && ( -d $outputDir ) ) {
		print "\nWARNING: Removing directory '$orig_cwd/$outputDir'\n\n";
		remove_tree($outputDir);
	}

	# If the output directory has not been defined, give it a name based on
	# the current date and time
	unless ( defined $outputDir ) {
		my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime(time);
		$year += 1900;
		my @abbr = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
		my $timedate = sprintf( "${abbr[$mon]}_${mday}_${year}-%02d_%02d_%02d", $hour, $min, $sec );
		$outputDir = "SageBIOS${releasetype}-${timedate}";
	}

	# If the input directory was not specified, assume that it's the current
	# dir
	$inputDir = cwd() unless defined($inputDir);
	$inputDir =~ s!(.*)\/\z!$1!;

	$escapedInputDir = $inputDir;
	$escapedInputDir =~ s/([\$|\?|\.|\*|\+])/\\$1/g;

	# Verify that we're actually pointed to a sagebios/coreboot directory
	unless ( ( -e "$inputDir/src" ) && ( -e "$inputDir/src/arch" ) ) {
		die("ERROR: Please set the --input flag to the location of your sagebios/coreboot directory and retry.");
	}

	# Initialize variables for string replacement
	if ( defined $ENV{'SAGE_HOME'} ) {
		$sage_home = $ENV{'SAGE_HOME'};
	} else {
		die("ERROR: No build tools found.  Please install the Sage EDK.\n Go to http://www.se-eng.com/sage-edk.html");
	}

	$dotconfigfile = "$inputDir/$dotconfigfile";

	print "Input Dir:  $inputDir\n";
	print "Output Dir: $orig_cwd/$outputDir\n";
}

###############################################################################
#
# FUNCTION:    debug
# DESCRIPTION: Log and print debug information if necessary.
#
###############################################################################
sub debug {
	push( @debugtext, @_ );
	#print debug is specified on the command line.
	#by default, all debug text gets logged to a file
	if ($print_debug) {
		while (@_) { print "DEBUG: ", shift, "\n"; }
	}
}

###############################################################################
#
# FUNCTION:    find_dependency_files
# DESCRIPTION: Find all files ending in .d or .dependency recursively
# Returns: An array of all .d files
#
###############################################################################
sub find_dependency_files {
	my $dir = shift;
	my @files = File::Find::Rule->file
		->name('*.d','*.dependency','.dependencies')
		->in($dir);
	return @files;
}

###############################################################################
#
# FUNCTION:    gather_dependencies
# DESCRIPTION: Parse all dependencies listed in the .d file, then climb
#		the directory tree until we get a match on an absolute path
#		for that file. If found, add the file to an array.
# Returns: An array of absolute file paths necessary to build
#
###############################################################################
sub gather_dependencies {
	my $_dependency_files = shift;
	my @dependency_files =  @$_dependency_files;
	my @dependencies;
	my $XGCC_LIB_PATH_REGEX = ".*?lib.*?gcc.*include.*";

	foreach my $dep_file (@dependency_files) {
		open my $fh, "<",$dep_file or finish ("Cannot open $dep_file: $!");
		my @dependency_file = <$fh>;
		close $fh;

		# Fix parent path for libpayload sources, if necessary so search
		# algorithm is able to locate the sources correctly.
		$dep_file =~ s!(.*/payloads).*/libpayloadbin!$1/libpayload!;

		@dependency_file = join_lines(@dependency_file); # combine lines joined with a trailing backslash

		foreach my $line (@dependency_file) {

			# Ignore all lines in the file that are not make targets with
			# dependency lists
			next unless (($line =~ s/.*://) || ($line =~ s/.*_DEPS \+=//));

			my @individual_files = split(" ", $line);

			foreach my $individual_file (@individual_files) {
				if ( $individual_file !~ /$XGCC_LIB_PATH_REGEX/) {
					my $fileFound = 0;
					if (! -f $individual_file) {
						my @file_rel_path = split("/", $dep_file);

						# Remove the .d file name to get parent directories
						pop @file_rel_path;

						# Keep climbing directories until we fild the listed
						# file's absolute path
						while (! $fileFound && @file_rel_path) {
							my $abs_file_path = join("/", @file_rel_path, $individual_file);
							if (-f $abs_file_path) {
								$individual_file = $abs_file_path;
								$fileFound = 1;
							}
							pop (@file_rel_path);
						}
					} else {
						$fileFound = 1;
					}

					push @dependencies, $individual_file unless ($individual_file ~~ @dependencies || !$fileFound);
				}
			}
		}
	}
	return @dependencies;
}

###############################################################################
#
# FUNCTION:    copy_files
# DESCRIPTION: Copy all required files from $inputDir to $outputDir
# Param: @fileList - absolute paths of all files to copy from $inputDir
#
###############################################################################
sub copy_files {

	# Copy each input file to the output location
	# Input files are specified as a path from the coreboot directory.
	foreach my $file (@_) {
		my $file_loc = $file;
		$file =~ s!$escapedInputDir/!!;
		$file =~ s!\$ROOTDIR/!!;

		# TODO: Implement robust mechanism for identifying "proprietary" files
		#       instead of assuming that everything outside of the coreboot
		#       folder is proprietary.  The mechanism may also be something
		#       that is flexible enough to handle including proprietary files
		#       in a release package, if desired.

		if ($file =~ m#^\.\./.*#) {
			# NOTE: A source file that is referenced as a dependency of any
			#       source file that is built into coreboot romstage or
			#       ramstage can NOT be proprietary, no matter what folder it
			#       "lives" in.
			unless (($include_proprietary_code) || ($file =~ m/.*\.[c|h]/)) {
				push @proprietary_files, $file if ( -f $file );
				push @proprietary_dirs,  $file if ( -d $file );
				next;
			}
			push @included_proprietary_files, $file;
		}

		rcopy ($file_loc, "$package_path/$file") or finish ( "Failed to copy $file_loc to $package_path/$file: $!" );
		debug ("Copied $file_loc to $package_path/$file");
	}
}

###############################################################################
#
# FUNCTION:    gather_license_files
# DESCRIPTION: Find all "Copying" and/or "License" files recursively in
#              $inputDir and copy any whose parent directory exists in
#              $outputDir
#
###############################################################################
sub gather_license_files {
	my @temp_file_list = File::Find::Rule->file
				->name('COPYING*', 'license.txt', 'LICENSE*')
				->in($inputDir);
	my @files;
	foreach my $file (@temp_file_list) {
		my $new_file = $file;
		$new_file =~ s/$escapedInputDir/$package_path/;
		my @directory = split("/", $new_file);
		pop (@directory);
		my $new_dir_path = join("/", @directory);
		if (-d $new_dir_path) {
			$file =~ s#$escapedInputDir/?##;
			push (@files, $file) unless ($file ~~ @files);
		}
	}
	return @files;
}

###############################################################################
#
# FUNCTION:    create_filtered_build_script
# DESCRIPTION: Collect the output of make --dry-run in $inputDir, then process
#		the output to make the script portable
#
###############################################################################
sub create_filtered_build_script {
	my @file_list;
	my @script = generate_build_script();

	@script = join_lines(@script); # combine lines joined with a trailing backslash

	foreach my $line (@script) {
		$line = update_payload_dirs($line);
		$line = filter_line($line);                # simple filters
		$line = add_xip_base_address($line);
		$line = convert_cd_to_pushd($line);
		$line = replace_cbfstool_commands($line);  # coreboot.rom filters
		$line = replace_install_directives($line); # libpayload filters
		$line = replace_ifdtool_commands($line);   # coreboot.rom filters
		$line = replace_cat_commands($line);       # coreboot.rom filters

		# TODO: Pick up files from cbfstool, linker files and scripts as the
		#       build script is "filtered".
	}

	add_mkdir_directives(\@script);

	unshift (@script, add_to_top_of_script());

	# Additions to the bottom of the script
	push (@script, "exit 0");
	print_build_script("build", \@script);
	return @script;
}

###############################################################################
#
# add_to_top_of_script
#
###############################################################################
sub add_to_top_of_script {
	my $header = << 'EOF';
#!/bin/bash -ex

export ROOTDIR=${PWD}
if [ "$SAGE_HOME" == "" ]; then
echo "ERROR: Cross compiler not found."
echo "Please install the Sage EDK."
echo "http://www.se-eng.com/products/sage-edk/"
exit 1
fi

EOF

	return $header;
}

###############################################################################
#
# FUNCTION:    find_special_files
# DESCRIPTION: Find files that are needed but hidden in the makefiles
#
###############################################################################
sub find_special_files {
	my (@script, @special_file_list) = @_;

	foreach my $line (@script) {
		my $templine = $line;

		# special rule to include SeaBIOS code16gcc.s
		if ($line =~ m!src/code16gcc\.s!) {
			my $file = "$inputDir/payloads/seabios/src/code16gcc.s";
			push (@special_file_list, $file) unless ($file ~~ @special_file_list);
		}

		# special rule to include the coreboot mainboard's cmos.layout file
		if ($line =~ m!nvramtool\s+-y.*?(src/mainboard/.*/cmos\.layout)\s+-L build/cmos_layout\.bin$!) {
			my $file = "$inputDir/$1";
			push (@special_file_list, $file) unless ($file ~~ @special_file_list);
		}

		# special rule to include the coreboot mainboard's "fake" SPD file
		while ($templine =~ s!(src/mainboard/.+?\.spd\.hex)!!) {
			my $file = "$inputDir/$1";
			push (@special_file_list, $file) unless ($file ~~ @special_file_list);
		}

		# special rule to include binaries included by cbfstool
		if ($templine =~ m!build/cbfstool!) {
			# NOTE: Sometimes multiple cbfstool commands will be concatenated
			#       into a single line in the build script.
			my @files = split(";", $templine);
			foreach my $file (@files) {
				 if ($file =~ m!build/cbfstool\s.*?-f\s"?(.*?)"?\s!) {
				 	my $tmp_file = $1;
				 	$tmp_file =~ s#^\./##; # Remove leading "./"
				 	$tmp_file = "$inputDir/$tmp_file" unless ($tmp_file =~ m/$escapedInputDir/);
					push (@special_file_list, "$tmp_file") unless ("$tmp_file" ~~ @special_file_list);
				}
			}
		}

		# special rule to include .config included by payloads
		if ($line =~ m!(payloads/.*/libpayloadbin/.config)!) {
			my $file = "$inputDir/$1";
			push  (@special_file_list, $file) unless ($file ~~ @special_file_list);
		}

		# special rule to include libpayload/configs included by payloads
		if ($line =~ m!install.*(configs/.*?)\s!) {
			my $file = "$inputDir/payloads/libpayload/$1";
			push (@special_file_list, $file) unless ($file ~~ @special_file_list);
		}
	}

	return @special_file_list;
}

###############################################################################
#
# FUNCTION:    find_tools_and_scripts
# DESCRIPTION: Find additional tools that need to be copied over
#
###############################################################################
sub find_tools_and_scripts {
	my @script = @_;
	my @toollist;
	my @previous_dir;
	my $current_dir = $inputDir;

	# coreboot tools and scripts
	my $genbuild_h = "util/genbuild_h/genbuild_h.sh";

	# libpayload tools and scripts
	my $lp_funcs   = "bin/lp.functions";
	my $lpgcc      = "bin/lpgcc";
	my $lpas       = "bin/lpas";

	foreach my $line (@script) {

		# Handle the known tools
		if ( ($genbuild_h) && ( $line =~ m/$genbuild_h/ ) ) {
			$genbuild_h = "$inputDir/$genbuild_h";
			push( @toollist, $genbuild_h ) unless ( $genbuild_h ~~ @toollist );
			$genbuild_h = "";
		}

		# Handle libpayload scripts
		if ( ($lpgcc) && ( $line =~ m/$lpgcc/ ) ) {
			my $tool = "$inputDir/payloads/libpayload/$lpgcc";
			push( @toollist, $tool ) unless ( $tool ~~ @toollist );
			$lpgcc = "";
			if ( $lp_funcs ) {
				$tool =~ s/$lpgcc/$lp_funcs/;
				push( @toollist, $tool ) unless ( $tool ~~ @toollist );
				$lp_funcs = "";
			}
		}
		if ( ($lpas) && ( $line =~ m/$lpas/ ) ) {
			my $tool = "$inputDir/payloads/libpayload/$lpas";
			push( @toollist, $tool ) unless ( $tool ~~ @toollist );
			$lpgcc = "";
			if ( $lp_funcs ) {
				$tool =~ s/$lpgcc/$lp_funcs/;
				push( @toollist, $tool ) unless ( $tool ~~ @toollist );
				$lp_funcs = "";
			}
		}

		# Track the script's pushd / popd so we can pick up where payload's files are
		if ( $line =~ m/pushd (.*)/ ) {
			push (@previous_dir, $current_dir) unless ($current_dir eq "");
			$current_dir = $1;
			$current_dir =~ s/\$ROOTDIR/$inputDir/;
			debug("payload dir is now $current_dir - $line");
		}
		if ( ( $current_dir ne "" ) && ( $line =~ m/popd/ ) ) {
			if (@previous_dir) {
				$current_dir = pop(@previous_dir);
			} else {
				$current_dir = "";
			}
			debug("payload dir is now $current_dir - $line");
		}

		# Grab .sh & .py files for the SeaBIOS, *.pl files for the IPXE
		if ( $line =~ m#\S*?.?/?((?:scripts|util)/.*?\.(?:sh|py|pl))# ) {
			my $tool = $1;
			unless ($tool =~ m/$escapedInputDir/) {
				$tool = "$current_dir/$tool";
				my $dir = join("/", @previous_dir) if (@previous_dir);
				$tool = "$dir/$tool" if defined($dir);
			}
			unless ( "$tool" ~~ @toollist ) {
				debug("adding $tool");
				push( @toollist, "$tool" );
			}
		}

		# Grab linker scripts
		if ( $line =~ m!.*\.(?:lb|ldscript|lds|ld)\b! ) {
			my @split_line = split(" ", $line);
			foreach my $spl (@split_line) {
				next unless ( $spl =~ m!([\w|/|.|_|-]+\.(?:lb|ldscript|lds|ld)\b)! );

				my $linker_script = $1;

				# Unless the linker script is already using an absolute path name,
				# combine any previous pushd instructions into a single directory
				# and prepend to the linker script name (For example, ipxe will
				# have at least two entries in the pushd stack, first is
				# "payloads/ipxe", second is "src", they must be combined for ipxe
				# paths to be "payloads/ipxe/src".)
				$linker_script = "$current_dir/$linker_script" unless ($linker_script =~ m/$escapedInputDir/);

				unless ($linker_script =~ m/$escapedInputDir/) {
					my $dir = join("/", @previous_dir) if (@previous_dir);
					$linker_script = "$dir/$linker_script" if (defined($dir));
				}

				if ( -f $linker_script) {
					unless ( "$linker_script" ~~ @toollist ) {
						debug("adding $linker_script");
						push( @toollist, "$linker_script" );
					}
				}
			}
		}
	}
	return @toollist;
}

###############################################################################
#
# FUNCTION:    find_required_script_modules
# DESCRIPTION: The seabios python scripts and ipxe perl scripts have
#              dependencies on modules included from the same directory.  The
#              python dependencies are declared with a 'from MODULENAME import'
#              or 'import MODULENAME' command.  The perl dependencies are
#              declared with a 'use OPTIONAL_DIR::PACKAGE;' command.
#
###############################################################################
sub find_required_script_modules {
	my @additional_files = @_;

	foreach my $filename (@additional_files) {

		# Read in all python and perl scripts for parsing
		next unless ($filename =~ m/\.(?:py|pl)\z/);

		open my $fh, "<", "$filename" or finish ("Could not open $filename: $!");
		my @file_lines = <$fh>;
		close $fh;

		# Parse the script for the 'from MODULENAME import' text,
		# 'import MODULENAME' text or the 'use OPTIONAL_DIR::PACKAGE;' text
		# and add it to the list of required files (NOTE: Python allows
		# multiple modulename's on a single 'import' line)
		foreach my $line (@file_lines) {
			my $tool = "";

			#### Handle required python modules ####

			# Example: from python23compat import as_bytes
			if ($line =~ m/from\s(\S+)\simport/) {
				$tool = dirname($filename) . "/$1.py";

			# Example: import layoutrom, buildrom
			} elsif ($line =~ m/import\s(.*)/) {
				my @packages = split(",", $1);
				foreach my $package (@packages) {
					my $tmp = $package;
					$tmp =~ s/\s//g; # Remove extra spaces around package name
					$tmp = dirname($filename) . "/$tmp.py";
					if (-f $tmp) {
						debug "adding: $tmp - $line";
						push (@additional_files, $tmp) unless ($tmp ~~ @additional_files);
					}
				}

			#### Handle required perl modules ####

			# Example: use Option::ROM
			} elsif ($line =~ m/use\s(\S+).*;/) {
				my $file = $1;

				# Replace :: with / e.g. "use Option::ROM" becomes "Option/ROM"
				$file =~ s!::!/!;
				$tool = dirname($filename) . "/$file.pm";
			}

			if (-f $tool) {
				debug "adding: $tool - $line";
				push (@additional_files, $tool) unless ($tool ~~ @additional_files);
			}
		}
	}

	return @additional_files;
}

###############################################################################
#
# FUNCTION:    update_payload_dirs
# DESCRIPTION: Switch to the payload directories
#
###############################################################################
sub update_payload_dirs {
	my $line = shift;

	#TODO: the starting filter could look at make -C
	if ($line =~ m!Starting.*?build in\s(.*)"!) {
		$line = "pushd $1";
	} elsif ($line =~ m/Finished.*?build in (.*)"/) {
		$line = "popd # $1";
	}

	return $line;
}

###############################################################################
#
# FUNCTION:    join_lines
# DESCRIPTION: find lines connected with a terminating backslash and append
#              the following line.
#
###############################################################################
sub join_lines {
	my @script = @_;
	my @newscript;

	# Find lines terminated with a backslash and join it with the following
	# line
	while (my $line = shift(@script)) {
		chomp($line);
		while ($line =~ m/\s+\\\Z/) {
			$line =~ s/\s+\\\Z/ /;
			my $newline = shift (@script);
			chomp($newline);
			$newline =~ s/^\s*//;
			$line .= $newline;
		}
		push @newscript, $line;
	}
	return @newscript;
}

###############################################################################
#
# FUNCTION:    filter_line
# DESCRIPTION: filter the simple items out of the buildscript.  This can remove
#              a full line, sections of a line, or do a simple search and
#              replace.
#
#              Complex serarch and replace is done in separate functions.
#
###############################################################################
sub filter_line {
	my $line = shift(@_);
	my @filters = (

		# Remove all 'printf', 'echo', and comments
		{string=>'printf\s*".*"\s*$',                   flag_rmline=>1},	# Remove printf "" lines
		{string=>'echo\s*["\'].*["\']\s*$',             flag_rmline=>1},	# Remove echo "" or echo '' lines
		{string=>'^#\s',                                flag_rmline=>1},	# Remove comments

		# Remove errors caused by 'cat'-ing a file that does not exist during
		# the dry-run
		{string=>'cat:.*No such file or directory',     flag_rmline=>1},    # Remove "No such file or directory" lines

		{string=>'^make',                               flag_rmline=>1},	# Remove 'make' lines - if projects are configured correctly, they're not needed anymore

		{string=>'util/([ks]config)',                   flag_rmline=>1},	# Remove anything that uses kconfig or sconfig, since we're keeping config.h and static.c
		{string=>'romstage_null\.debug \| grep -q',     flag_rmline=>1},	# Remove the grep looking for forbidden variables

		{string=>'cp ../intel.*?.c',                    flag_rmline=>1},	# Remove lines copying in the intel .c files
		{string=>'build/microcode_size.tmp',            flag_rmline=>1},	# Remove the microcode calculation files
		{string=>'if \[ -f .*config.* \];',             flag_rmline=>1},
		{string=>'\s+\|\|\s+{ echo "The r.*exit 1;\s+}',flag_rmtext=>1},

		# Update paths
		{string=>"$sage_home",    new=>'"$SAGE_HOME"',  flag_replace=>1},	# Change all paths pointing to the tools
		{string=>"$escapedInputDir", new=>'$ROOTDIR',   flag_replace=>1},	# Update all internal paths

		# Remove the romstage variable check
		{string=>'Forbidden\s+global\s+var',            flag_rmline=>1},	#

		# seabios specific
		{string=>'scripts/kconfig',                     flag_rmline=>1},	# Remove the kconfig build
		{string=>'\$ROOTDIR/payloads/seabios/src/',     flag_rmtext=>1},	# We cd to the dir, so remove the full path

		# libpayload specific
		{string=>'cmp.*?libpayload-config\.h.*/',       flag_rmline=>1},	# Remove line that copies config.h to libpayload-config.h

		# ipxe specific
		{string=>'\s\[DEPS\]\s',                        flag_rmline=>1},	# Remove all [DEPS] lines for ipxe
	);

	for my $i (0 ..  $#filters) {
		if ($line =~ m/${filters[$i]{string}}/) {
			if (exists $filters[$i]{flag_rmline}) {
				debug ("Filter $i Removed line: $line");
				$line = "";
				last;
			} elsif (exists $filters[$i]{flag_replace}) {
				debug ("Filter $i Changed line: $line");
				$line =~ s/${filters[$i]{string}}/${filters[$i]{new}}/g;
				debug ("to: $line");
			} elsif (exists $filters[$i]{flag_rmtext}) {
				debug ("Filter $i Removed text from line: $line");
				$line =~ s/${filters[$i]{string}}//g;
				debug ("changing it to: $line");
			}
		}
	}
	return $line;
}

###############################################################################
#
# FUNCTION:    generate_build_script
# DESCRIPTION: Collect the output of make --dry-run in $inputDir
# Returns: The output of --dry-run as an array
#
###############################################################################
sub generate_build_script {

	chdir $inputDir unless ( $inputDir eq $orig_cwd );

	# Clean the workspace
	make_sagebios("clean", "");
	make_sagebios("distclean-payloads", "");

	# Check for remaining *.o, *.so, *.a, etc. files and throw warning if make
	# clean/distclean-payloads did not completely clean the workspace.
	my @temp_file_list = File::Find::Rule->file
				->name('*.o', '*.so', '*.a')
				->in($inputDir);
	if (@temp_file_list) {
		print "WARNING: Workspace is not clean after running 'make clean' and 'make distclean-payloads'\n";
		my $line = join("\n", @temp_file_list);
		print "$line\n";
	}

	my $dryrun_output = make_sagebios("", "--dry-run ROUND_TIME=1");
	my @buildScript   = split( "\n", $dryrun_output );
	chdir $orig_cwd unless ( $inputDir eq $orig_cwd );
	return @buildScript;
}

###############################################################################
#
# FUNCTION:    make_sagebios
# DESCRIPTION: go into $input dir and run make
#
###############################################################################
sub make_sagebios {
	my ( $make_target, $makeargs ) = @_;
	chdir $inputDir unless ( $inputDir eq $orig_cwd );
	my $output   = qx(make $make_target $makeargs 2>&1);
	my $exitcode = $? >> 8;
	debug($output);
	chdir $orig_cwd unless ( $inputDir eq $orig_cwd );

	finish("make $make_target $makeargs failed with an errorlevel of $exitcode ") if $exitcode;
	return $output;
}

###############################################################################
#
# FUNCTION:    add_mkdir_directives
# DESCRIPTION: Find all the parent directories needed by any generated .o
#		file and add mkdir -p lines in the buildscript
#
###############################################################################
sub add_mkdir_directives {
	my $lines = shift (@_);
	my $object_file_dir_pattern = "\\s-o\\s(.*?)\\s";
	my @dirs_to_make;

	my $current_dir = "";
	my @previous_dir;
	foreach my $line (@$lines) {
		# Track the script's pushd / popd so we can pick up where payload's files are
		if ( $line =~ m/pushd (.*)/ ) {
			push (@previous_dir, $current_dir) unless ($current_dir eq "");
			$current_dir = $1;
			debug("payload dir is now $current_dir - $line");
		}
		if ( ( $current_dir ne "" ) && ( $line =~ m/popd/ ) ) {
			if (@previous_dir) {
				$current_dir = pop(@previous_dir);
			} else {
				$current_dir = "";
			}
			debug("payload dir is now $current_dir - $line");
		}

		if ($line =~ m/$object_file_dir_pattern/) {
			my $path = $1;
			unless ($path =~ m/ROOTDIR/) {
				$path = "$current_dir/$1" unless ($current_dir eq "");
				my $dir = join("/", @previous_dir) if (@previous_dir);
				$path = "$dir/$path" if defined($dir);
			}

			my @file_path = split ("/", ($path));
			pop (@file_path);
			my $dir_path = join ("/", @file_path);
			push (@dirs_to_make, $dir_path) unless ($dir_path ~~ @dirs_to_make || $dir_path eq "");
		}
	}

	# Add the mkdir lines to the top of the build script
	foreach my $dir (@dirs_to_make) {
		$dir =~ s#\$ROOTDIR/##; # Remove leading "$ROOTDIR"
		unshift (@$lines, "mkdir -p $dir");
	}
}

###############################################################################
#
# FUNCTION:    replace_ifdtool_commands
# DESCRIPTION: The --dry-run can pick up commands from coreboot, that perform
#              additional processing on proprietary binaries which may be
#              excluded from the packaged sources.  Add a check for the file's
#              existence before running the command.  Leaving the commands in
#              the OSP build script enables a customer to include the
#              proprietary binaries if they are able to acquire them from the
#              vendor.
#
###############################################################################
sub replace_ifdtool_commands {
	my $line = shift(@_);

	my $dd_command   = "dd\\s.*if=(.*?)\\s";
	my $ifdtool_cmd  = ".*ifdtool\\s-i\\s(?:ME:)*(.*?)\\s";
	my $ifd_tmp_file = "mv\\s(.*coreboot\.pre\.new)";

	if (($line =~ m/$dd_command/)   ||
	    ($line =~ m/$ifdtool_cmd/s) ||
	    ($line =~ m/$ifd_tmp_file/))
	{
		my $file_name = $1;
		debug ("Filter Changed line: $line");
		$line = "if [ -e $file_name ]; then " . $line . " ; fi";
		debug ("to: $line");
	}

	return $line;
}

###############################################################################
#
# FUNCTION:    replace_cbfstool_commands
# DESCRIPTION: The --dry-run can pick up cbfstool commands from coreboot for
#              proprietary binary files that are excluded from the packaged
#              sources.  Add a check for the file's existence before running
#              the cbfstool command.  Leaving the cbfstool commands in the OSP
#              build script enables a customer to include the proprietary
#              binaries if they are able to acquire them from the vendor.
#
###############################################################################
sub replace_cbfstool_commands {
	my $line = shift(@_);

	if ($line =~ m/cbfstool/) {
		my $file_name;
		my $rom_name;
		my @outputs;
		my @inputs = split(";", $line);
		foreach my $input (@inputs) {

			if ($input =~ m# -n (.*?) -#) {
				$rom_name = $1;
			}
			if ($input =~ m# -f (.*?) -#) {
				$file_name = $1;
			}

			if (defined($rom_name) && defined($file_name)) {
				$rom_name  =~ s/["|\s]//g; # Remove all quotes and whitespace from around CBFS name
				$file_name =~ s/["|\s]//g; # Remove all quotes and whitespace from around File name
				$file_name =~ s!$escapedInputDir/!!;
				$file_name =~ s!\$ROOTDIR/!!;
				$cbfs_files{$rom_name} = $file_name;
			}

			if (defined($file_name)) {
				debug ("Filter Changed line: $input");
				$input = "if [ -e $file_name ]; then " . $input . " ; fi";
				debug ("to: $input");
				undef($file_name);
			}

			push(@outputs, $input);
		}

		$line = join(" ; ", @outputs);
	}

	return $line;
}

###############################################################################
#
# FUNCTION:    replace_install_directives
# DESCRIPTION: The --dry-run can pick up install directives from libpayload for
#              header files that do not exist in the packaged sources.  Add a
#              check for the file's existence before running the install
#              directive.  Trying to remove specific files by name would
#              eliminate all flexibilty for developing payloads based on
#              libpayload in SageBIOS.
#
###############################################################################
sub replace_install_directives {
	my $line = shift(@_);
	my $install_dir  = "install.*\\s-d\\s";
	my $install_file = "install.*\\s(.*\\.h)\\s";

	my @outputs;
	my @inputs = split(";", $line);
	foreach my $input (@inputs) {
		unless ($input =~ m/$install_dir/) {
			if ($input =~ m/$install_file/) {
				my $file = $1;
				debug ("Filter Changed line: $input");
				$input = "if [ -e $file ]; then " . $input . " ; fi";
				debug ("to: $input");
			}
		}
		push(@outputs, $input);
	}

	$line = join(";", @outputs);

	return $line;
}


###############################################################################
#
# FUNCTION:    replace_cat_commands
# DESCRIPTION: The --dry-run can pick up cat commands from coreboot for
#              binary files that do not exist in the packaged sources.  Add a
#              check for the file's existence before running the cat command.
#              Leaving the cat commands in the OSP build script enables a
#              customer to include the proprietary binaries if they are able to
#              acquire them from the vendor.
#
###############################################################################
sub replace_cat_commands {
	my $line = shift(@_);
	my $cat_command = "cat\\s+(\\S*)\\s*";

	if ($line =~ m/$cat_command/) {
		my $file = $1;
		debug ("Filter Changed line: $line");
		$line = "if [ -e $file ]; then " . $line . " ; fi";
		debug ("to: $line");
	}

	return $line;
}

###############################################################################
#
# FUNCTION:    add_xip_base_address
# DESCRIPTION: The --dry-run tries to do a cat on base_xip.txt, which doesn't
#		exist at the time dry-run is executed. Replace the empty
#		space left with an actual cat directive that will run at
#		build time
# WARNING: This subroutine must be called BEFORE replace_cbfstool_commands in
#          order for the regular expression to match.  This is because
#          replace_cbfstool_commands wraps all cbfstool commands with a check
#          for the file to exist which terminates every line with "; fi".
#
###############################################################################
sub add_xip_base_address {
	my $line = shift(@_);
	my $empty_base_option = "\\s*-b\\s*\$";

	if ($line =~ m/$empty_base_option/) {
		$line =~ s/$empty_base_option/	-b \$\( cat build\/cbfs\/fallback\/base_xip.txt \)/
	}
	return $line;
}

###############################################################################
#
# FUNCTION:    convert_cd_to_pushd
# DESCRIPTION: We need to replace any cd directive with a pushd/popd
#		so bash doesn't put us in a weird place.
#
###############################################################################
sub convert_cd_to_pushd {
	my $line = shift(@_);

	#if the line contains a 'cd' directive, replace it with a pushd
	#add a popd as the next line.
	if ($line =~ m/^\s*cd/) {
		$line =~ s/^\s*cd/pushd/;
		$line = "$line\npopd";
	}
	return $line;
}

###############################################################################
#
# FUNCTION:    collect_additional_required_files
# DESCRIPTION: Find other binary/c files explicitly called out in
#		config.h and copy them to $outputDir
#
###############################################################################
sub collect_additional_required_files {

	my $config_file = "$inputDir/build/config.h";
	open my $fh, "<", "$config_file" or finish ("Could not open config file $config_file: $!");
	my @configLines = <$fh>;
	close $fh;

	my $payload_var = "CONFIG_PAYLOAD.*_FILE";

	my @files;
	foreach my $line (@configLines) {
		if ($line =~ m/CONFIG_.*?_(FILE|PATH) \"(.*?)\"/ && $line !~ m/$payload_var/) {
			if ($line =~ m/CONFIG_MICROCODE_INCLUDE_PATH/) {
					#microcode files get picked up by a .d file
					next;
			}

			my $relFile = $2;
			if ($relFile eq "") {
				next;
			}

			if ($line !~ m/$payload_var/) {
				$relFile =~ s#^\./##; # Remove leading "./"
				$relFile = "$inputDir/$relFile" unless ($relFile =~ m/$escapedInputDir/);
				push @files, $relFile unless ($relFile ~~ @files);
			}
		} elsif ($line =~ m/CONFIG_.*_FILE_IN.*\s\"(.*?)\"/) {
			my $relFile = $1;
			if ($relFile eq "") {
				next;
			}

			# Get path/file described by CONFIG_CBFS_FILE_FILE_IN (ignore
			# FILE_OUT because it does not provide the path to the file.)
			if ($line !~ m/$payload_var/) {
				$relFile =~ s#^\./##; # Remove leading "./"
				$relFile = "$inputDir/$relFile" unless ($relFile =~ m/$escapedInputDir/);
				push @files, $relFile unless ($relFile ~~ @files);
			}
		}
	}
	return @files;
}

###############################################################################
#
# FUNCTION:    print_build_script
# DESCRIPTION: Print out and chmod a build script into $outputDir
# Parameter: Type - the type of buildscript it is, build or clean
#
###############################################################################
sub print_build_script {
	my $type = shift(@_);
	my $buildScript = shift(@_);
	open my $fh, '>', "$package_path/$type.sh" or finish ("Could not write to $package_path/$type.sh: $!");
	foreach (@$buildScript) {
		print $fh "$_\n" unless ($_ eq "");
	}
	close $fh;
	chmod 0777, "$package_path/$type.sh";
}

###############################################################################
#
# FUNCTION:    generate_clean_script
# DESCRIPTION: generate all lines for the clean.sh script in $outputDir
#
###############################################################################
sub generate_clean_script {
	my @cleanScript = <<'EOF';
#!/bin/bash -x

pushd build > /dev/null
  find mainboard -name "*.aml" -o -name "*.asl" -o -name "*.hex" -o -name "romstage*" | xargs rm -Rf
  find . -name "*.d" -o -name "*.o" -o -name "*.a" | xargs rm -Rf
  find . -type d -empty -delete
  rm -rf mrc.cache build.h ./*.bin ./*pre* ldoptions option_table.h
  rm -rf cbfstool rmodtool cpu cbfs util
  rm -rf generated coreboot*.rom soc
popd > /dev/null

  if [ -d payloads ]; then
    pushd payloads > /dev/null
    find . -name "*.d" -o -name "*.o" -o -name "*.elf" -o -name "*.rom" | xargs rm -Rf
    find . -name "*.bin" -o -name "*.tmp" -o -name "*.zbin" -o -name "*.zinfo" | xargs rm -Rf
    find . -name "*.exe" -o -name ".depend" -o -name "*.lst" -o -name "*.objdump" | xargs rm -Rf
    find . -name "*.a" -o -name "*.debug" -o -name "*.map" | xargs rm -Rf

    for directory in $( find . -name "libpayloadbin" ) ; do
        pushd $directory > /dev/null
                for file in $( find . -type f -name *.h ) ; do
                        if [ ! "$file" == "./build/libpayload-config.h" ] ; then
                                rm $file
                        fi
                done
                find . -name "lpgcc" -o -name "lpas" -o -name "lp.functions" | xargs rm -Rf
                find . -name "*.ldscript" -o -name "libpayload.config" | xargs rm -Rf
        popd > /dev/null
    done

    if [ -d ipxe ]; then
      pushd ipxe > /dev/null
      find . -name "zbin" | xargs rm -Rf
      popd > /dev/null
    fi

    if [ -d memtest86+ ]; then
      pushd memtest86+ > /dev/null
      find . -name "memtest_shared" -o -name "*.s" | xargs rm -Rf
      popd > /dev/null
    fi

    if [ -d seabios ]; then
      pushd seabios/out > /dev/null
      find . -name "*.i" -o -name "*.i.orig" -o -name "*.aml" | xargs rm -Rf
      find . -name "*.off" -o -name "*.o.tmp.c" -o -name "*.lds" | xargs rm -Rf
      find . -name "*.raw" -o -name "*.prep" -o -name "*.s" -o -name "*.hex" | xargs rm -Rf
      rm -rf include vgasrc version.c
      popd > /dev/null
      rm -rf seabios/scripts/*.pyc
    fi

    if [ -d sgabios ]; then
      pushd sgabios > /dev/null
      find . -name csum8 | xargs rm -Rf
      popd > /dev/null
    fi

    find . -type d -empty -delete

    popd > /dev/null
  fi
exit 0
EOF
	print_build_script("clean", \@cleanScript);
}

###############################################################################
#
# FUNCTION:    generate_makefile
# DESCRIPTION: generate all lines for the makefile in $outputDir
#
###############################################################################
sub generate_makefile {
	my $filename = "$package_path/Makefile";

	open my $fh, '>', $filename or finish ("Could not write to $filename");
	print $fh <<'EOF';
all:
	./build.sh

clean:
	./clean.sh
EOF
	close $fh;
	chmod 0777, $filename;
}

###############################################################################
#
# FUNCTION:    save_build_info
# DESCRIPTION: Saves all the information that was collected doing the build
#
###############################################################################
sub save_build_info {
	my ($message) = @_;
	my $info = "";

	# Save package creation info
	if (@proprietary_files) {
		$info .= "\n${hashline}# Proprietary Files (excluded from package) \n${hashline}";
		$info .= join("\n", @proprietary_files);
		$info .= "\n";
	}
	if (@proprietary_dirs) {
		$info .= "\n${hashline}# Proprietary Folders (excluded from package) \n${hashline}";
		$info .= join("\n", @proprietary_dirs);
		$info .= "\n";
	}
	if (@included_proprietary_files) {
		$info .= "\n${hashline}# Proprietary Files (included in package) \n${hashline}";
		$info .= join("\n", @included_proprietary_files);
		$info .= "\n";
	}
	if (@license_files) {
		$info .= "\n${hashline}# License file List \n${hashline}";
		$info .= join("\n", @license_files);
		$info .= "\n";
	}
	if (@org_cbfs_files) {
		$info .= "\n${hashline}# CBFS Directory List (original BSP) \n${hashline}";
		$info .= join("\n", @org_cbfs_files);
		$info .= "\n";
	}
	if (@new_cbfs_files) {
		$info .= "\n${hashline}# CBFS Directory List (open source package) \n${hashline}";
		$info .= join("\n", @new_cbfs_files);
		$info .= "\n";
		if (@excluded_cbfs_files) {
			$info .= "\n# Excluded Files (proprietary) \n";
			$info .= join("\n", @excluded_cbfs_files);
			$info .= "\n";
		}
		if (@binary_diff_files) {
			$info .= "\n# Binary Differences Found \n";
			$info .= join("\n", @binary_diff_files);
			$info .= "\n";
		}
	}
	if (@coreboot_required_files) {
		$info .= "\n${hashline}# Dependency List \n${hashline}";
		$info .= join("\n", @coreboot_required_files);
		$info .= "\n";
	}
	if (@addlFiles) {
		$info .= "\n${hashline}# Additional Files List \n${hashline}";
		$info .= join("\n", @addlFiles);
		$info .= "\n";
	}
	if (@toollist) {
		$info .= "\n${hashline}# Additional tools and scripts List \n${hashline}";
		$info .= join("\n", @toollist);
		$info .= "\n";
	}
	if (@debugtext) {
		$info .= "\n${hashline}# Debug Text \n${hashline}";
		$info .= join("\n", @debugtext);
		$info .= "\n";
	}

	open my $fh, '>', $outputlog or print ("***** ERROR: Could not write to $outputlog *****");
	print $fh <<"EOF";
${info}

${hashline}# SLOC Count
${hashline}${sloccount}

EOF

if ($message) {
		print $fh $message;
}

	close $fh;
}

###############################################################################
#
# create_package
#
###############################################################################
sub create_package {

	unless ( -e "$inputDir/build/config.h" ) {
		finish("A SageBIOS Open Source Package is generated from a completed SageBIOS build.\n" .
		       "Please build your BSP with the desired configuration before attempting to generate an OSP.");
	}

	print "\nCreating build script...\n";
	@buildScript = create_filtered_build_script();
	print "Done.\n";

	#The build script was generated against a clean build, we need to rebuild
	# here so that the generated files exist when the file copy is done below.
	print "\nBuilding SageBIOS (this might take a while)...\n";
	make_sagebios( "", "ROUND_TIME=1" );
	print "Done.\n";

	debug("Generating clean script");
	generate_clean_script();
	debug("Generating Makefile");
	generate_makefile();

	debug("Collecting dependency files");
	@coreboot_dependency_files = find_dependency_files($inputDir);

	debug("Parsing dependencies");
	@coreboot_required_files = gather_dependencies( \@coreboot_dependency_files );

	print "\n---- Copying Files to Open Source Package ----\n";

	debug("Copying required c and header files");
	copy_files(@coreboot_required_files);

	debug("Collecting additional files and tools");
	@addlFiles = collect_additional_required_files();

	debug("Finding tools and scripts");
	@toollist = find_tools_and_scripts(@buildScript);

	debug("Finding miscellaneous required files");
	@addlFiles = find_special_files(@buildScript, @addlFiles);

	debug("Finding required python and perl modules");
	@toollist = find_required_script_modules(@toollist);

	debug("Copying additional files");
	copy_files(@addlFiles);

	debug("Copying additional tools");
	copy_files(@toollist);

	debug("Collecting license files");
	@license_files = gather_license_files();

	debug("Copying license files");
	copy_files(@license_files);

	# Remove generated files that were copied because they are referenced in
	# the dependency files, but which embed full path information and are
	# therefore not portable.  The files are re-generated automatically by
	# running build.sh.
	my $exitcode = exec_in_path ("$outputDir/coreboot", "./clean.sh", $orig_cwd);
	if ($exitcode) {
		finish("Failed to execute the clean script");
	}

	if (@proprietary_files || @proprietary_dirs || @included_proprietary_files) {
		print "\nThe following files or folders are located outside of the coreboot tree and assumed to be proprietary.\n";

		if (@proprietary_files) {
			print "\nExcluded files:\n";
			my $line = join("\n", @proprietary_files);
			print "$line\n";
		}
		if (@proprietary_dirs) {
			print "\nExcluded folders:\n";
			my $line = join("\n", @proprietary_dirs);
			print "$line\n";
		}
		if (@included_proprietary_files) {
			print "\nWARNING: Included proprietary files or folders:\n";
			my $line = join("\n", @included_proprietary_files);
			print "$line\n";
			print "\nPlease review license and publishing requirements\n";
		}
	}

	print "\nPackage generated successfully.\n\n";
}

###############################################################################
#
# finish
#
###############################################################################
sub finish {
	my $message = shift;
	print "\n\nERROR: $message\n";

	#write out any debug information we can.
	save_build_info("\n\nERROR: $message\n");

	print "For details, look in $orig_cwd/$outputlog\n";

	#if we failed, clean up misc files
	if ( -d "${archive_test_dir}" ) {
		remove_tree($archive_test_dir);
	}

	exit 1;
}

###############################################################################
#
# exec_in_path
#
###############################################################################
sub exec_in_path {
	my ( $newpath, $cmd, $oldpath ) = @_;
	if (-d $newpath) {
		chdir "$newpath";
	} else {
		finish ("$newpath does not exist.");
	}

	my $output = qx(set -e ; $cmd 2>&1);
	debug("$output");
	my $exitcode = $? >> 8;
	chdir $oldpath;

	return $exitcode;
}

###############################################################################
#
# Get CBFS (coreboot file system) table of contents (TOC)
#
###############################################################################
sub get_cbfs_toc {
	my ($bin_path, $cbfs_img) = @_;

	my $cbfs_toc = "${outputDir}/cbfs_toc.txt";
	my $output   = qx($bin_path/cbfstool $cbfs_img print > $cbfs_toc 2>&1);
	debug("$output");
	my $exitcode = $? >> 8;
	if ($exitcode) {
		finish("Failed to retrieve directory list from coreboot file system");
	}

	my @cbfs_entries;
	open my $fh, "<",$cbfs_toc or finish ("Cannot open $cbfs_toc: $!");
	while (<$fh>) {
		next if (($_ =~ m/\(empty\)/) || ($_ =~ m/coreboot\.rom/));

		$_ =~ m/(.*?)\s*0x.*\s*.*\s*\d+/;
		push (@cbfs_entries, $1) if defined($1);
	}
	close $fh;

	unlink $cbfs_toc;

	return @cbfs_entries;
}

###############################################################################
#
# compare_binaries
#
###############################################################################
sub compare_binaries {
	my ($org_bin, $new_bin_path) = @_;
	my $new_bin = "${new_bin_path}/coreboot.rom";

	print "\nComparing Open Source Package coreboot filesystem to original BSP filesystem...\n";

	#TODO: ignore build strings (date/time/user name/domain name/etc.)

	# Get a "directory" listing from the original and new CBFS images.
	@org_cbfs_files = get_cbfs_toc($new_bin_path, $org_bin);
	@new_cbfs_files = get_cbfs_toc($new_bin_path, $new_bin);

	my @binary_matched_files;

	my $org_file = "org_cbfs_file.bin";
	my $new_file = "new_cbfs_file.bin";
	foreach my $cbfs_file_name (@org_cbfs_files) {

		# Ignore "config" file if present, config will never be included in OSP
		if ($cbfs_file_name eq "config") {
			push @excluded_cbfs_files, $cbfs_file_name;
			next;
		}

		unless ($cbfs_file_name ~~ @new_cbfs_files) {
			if ($cbfs_files{$cbfs_file_name} ~~ @proprietary_files) {
				push @excluded_cbfs_files, $cbfs_file_name;
				next;
			} else {
				unlink $org_file;
				unlink $new_file;
				finish ("$cbfs_file_name is missing from the open source package's coreboot file system");
			}
		}
		my $output = qx($new_bin_path/cbfstool $org_bin extract -n $cbfs_file_name -f $org_file 2>&1);
		my $exitcode = $? >> 8;
		if ($exitcode) {
			debug("$output");
			finish("Failed to read file $cbfs_file_name from original coreboot file system");
		}
		$output = qx($new_bin_path/cbfstool $new_bin extract -n $cbfs_file_name -f $new_file 2>&1);
		$exitcode = $? >> 8;
		if ($exitcode) {
			debug("$output");
			finish("Failed to read file $cbfs_file_name from packaged coreboot file system");
		}

		if (compare($org_file, $new_file) == 0) {
			push @binary_matched_files, $cbfs_file_name;
		} else {
			my $bindiff = qx(cmp -b $org_file $new_file 2>&1);
			push @binary_diff_files, ($cbfs_file_name, $bindiff);
		}

		unlink $org_file;
		unlink $new_file;
	}

	if (@binary_matched_files) {
		print "\n The OSP file(s) and the original BSP file(s) match:\n  ";
		my $line = join("\n  ", @binary_matched_files);
		print "$line\n";
	}
	if (@excluded_cbfs_files) {
		print "\n The original BSP file(s) were excluded from the OSP:\n  ";
		my $line = join("\n  ", @excluded_cbfs_files);
		print "$line\n";
	}
	if (@binary_diff_files) {
		# TODO: Make this error fatal when the binary compare is smart enough
		#       to handle diffing files with different date/time strings
		#       embedded in the image.
		print "\n WARNING: The OSP file(s) and the original BSP file(s) do not match:\n  ";
		my $line = join("\n  ", @binary_diff_files);
		print "$line\n";
	}

	print "\nBinary compare is correct.\n";
}

###############################################################################
#
# get_sloccount
#
###############################################################################
sub get_sloccount {
	my $printline  = 0;
	my $blanklines = 0;

	print "Calculating SLOCCount... ";
	$sloccount = qx(sloccount ${outputDir} 2>&1);
	my $exitcode = $? >> 8;
	if ( $exitcode == 127 ) {
		printf " Failed to execute sloccount. Not installed on system?\n";
		$sloccount = "Sloccount could not be executed\n";
	} elsif ($exitcode) {
		printf " Error executing sloccount.  Skipping.";
		$sloccount = "Error executing sloccount.\n";
	} else {
		$sloccount .= qx(sloccount --filecount ${outputDir} 2>&1);
		print "Done.\n";

		#just print useful information
		my @log = split( "\n", $sloccount );
		foreach my $line (@log) {
			if ( $line =~ m/^#Files\s+/ ) { $printline = 1; }
			if ( $line =~ m/^SLOC\s+/ )   { $printline = 1; }

			if ($printline) {
				if ( $line eq "" ) {
					$blanklines++;
				} else {
					$blanklines = 0;
				}

				if ( $blanklines le 1 ) {
					print "$line\n";
				}
			}

			if ( $line =~ m/Total Physical Source Lines/ ) { $printline = 0; }
			if ( $line =~ m/Total Number of Source Code/ ) { $printline = 0; }
		}
	}
}

###############################################################################
#
# check_package
#
###############################################################################
sub check_package {
	my $test_archive = shift(@_);

	my ($exitcode, $output);

	# Archive and test build in a new location - verifies that there are no
	# missing files, hard coded paths or relative paths outside of the OSP, in
	# the generated build script and/or clean script.
	qx(tar xzf $test_archive -C $extract_path );
	$exitcode = $? >> 8;
	if ($exitcode) {
		finish("Failed to extract Open Source Package in $extract_path");
	}

	print "\nBuilding Open Source Package...\n";
	my $arc_proj_dir = "$archive_test_dir/coreboot";
	$exitcode = exec_in_path ($arc_proj_dir, './build.sh', $orig_cwd);
	if ($exitcode) {
		finish("Open Source Package build failed with an errorlevel of $exitcode");
	}
	print " Built without error.\n";

	compare_binaries("${inputDir}/build/coreboot.rom", "$arc_proj_dir/build");

	# Run the clean script and compare for differences - verifies that all
	# build generated files are removed and that none of the OSP packaged
	# files were accidentally removed by the clean script.
	print "\nCleaning Open Source Package...\n";
	$exitcode = exec_in_path ($arc_proj_dir, "./clean.sh", $orig_cwd);
	if ($exitcode) {
		finish("Open Source Package clean failed with an errorlevel of $exitcode");
	}

	my $archive_clean = qx(diff -r $archive_test_dir "${outputDir}");
	debug("$archive_clean");
	$exitcode = $? >> 8;
	if ($exitcode) {
		finish("Open Source Package clean did not match original package contents");
	}
	print " Cleaned without error.\n";

	#clean up the archive test directory and file
	remove_tree($archive_test_dir);

	print "\nPackage verified successfully.\n\n";
}

###############################################################################
#
# archive_package
#
###############################################################################
sub archive_package {
	my ($archive_name) = @_;
	my $output = qx(tar czf $archive_name $outputDir);
	debug("$output");
	my $exitcode = $? >> 8;
	if ($exitcode) {
		finish("Failed to create Open Source Package: $archive_name");
	}
}

###############################################################################
#
# packager_main
#
###############################################################################
sub packager_main {

	print "----- SageBIOS Open Source Packager -----\n";
	set_options();
	set_directories();

	#set up the path variables
	$outputlog        = "${outputDir}/build.log";
	$package_path     = "${outputDir}/coreboot";
	$archive_name     = "${inputDir}/$outputDir.tar.gz";
	$extract_path     = "/tmp";
	$archive_test_dir = "$extract_path/$outputDir";

	make_path("$package_path");
	create_package();

	print "\n---- Making archive package ----\n";
	archive_package($archive_name);

	if ($checkpkg) {
		print "\n---- Checking package ----\n";
		check_package($archive_name);
	}

	if ($get_sloccount) {
		print "\n---- Calculating SLOC ----\n";
		get_sloccount();
	}

	save_build_info() if ($save_debug_log);

	print "\nSUCCESS: Files exported to $orig_cwd/$outputDir\n";
	print "           and $archive_name\n\n";
}
