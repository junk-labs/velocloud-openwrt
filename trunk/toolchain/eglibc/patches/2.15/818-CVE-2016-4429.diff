  * SECURITY UPDATE: stack exhaustion in clntudp_call
    - patches/any/CVE-2016-4429.diff: Use malloc/free for the error
      payload.
    - CVE-2016-4429

commit ce92632d1297d032e5781cfa077e300f5c167471
Author: Florian Weimer <fweimer@redhat.com>
Date:   Mon May 23 20:18:34 2016 +0200
Description: CVE-2016-4429: sunrpc: Do not use alloca in clntudp_call
  [BZ #20112]

    CVE-2016-4429: sunrpc: Do not use alloca in clntudp_call [BZ #20112]
    
    The call is technically in a loop, and under certain circumstances
    (which are quite difficult to reproduce in a test case), alloca
    can be invoked repeatedly during a single call to clntudp_call.
    As a result, the available stack space can be exhausted (even
    though individual alloca sizes are bounded implicitly by what
    can fit into a UDP packet, as a side effect of the earlier
    successful send operation).
    
    (cherry picked from commit bc779a1a5b3035133024b21e2f339fe4219fb11c)

	CVE-2017-4429
	[BZ #20112]
	* sunrpc/clnt_udp.c (clntudp_call): Use malloc/free for the error
	payload.

* The Sun RPC UDP client could exhaust all available stack space when
  flooded with crafted ICMP and UDP messages.  Reported by Aldy Hernandez'
  alloca plugin for GCC.  (CVE-2016-4429)

[Ubuntu note: pulled out changes to NEWS and ChangeLog to avoid patch
 conflicts -- sbeattie]

diff --git a/libc/sunrpc/clnt_udp.c b/libc/sunrpc/clnt_udp.c
index 1b6a20b..81d5637 100644
--- a/libc/sunrpc/clnt_udp.c
+++ b/libc/sunrpc/clnt_udp.c
@@ -420,9 +420,15 @@ send_again:
 	  struct sock_extended_err *e;
 	  struct sockaddr_in err_addr;
 	  struct iovec iov;
-	  char *cbuf = (char *) alloca (outlen + 256);
+	  char *cbuf = malloc (outlen + 256);
 	  int ret;
 
+	  if (cbuf == NULL)
+	    {
+	      cu->cu_error.re_errno = errno;
+	      return (cu->cu_error.re_status = RPC_CANTRECV);
+	    }
+
 	  iov.iov_base = cbuf + 256;
 	  iov.iov_len = outlen;
 	  msg.msg_name = (void *) &err_addr;
@@ -447,10 +453,12 @@ send_again:
 		 cmsg = CMSG_NXTHDR (&msg, cmsg))
 	      if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVERR)
 		{
+		  free (cbuf);
 		  e = (struct sock_extended_err *) CMSG_DATA(cmsg);
 		  cu->cu_error.re_errno = e->ee_errno;
 		  return (cu->cu_error.re_status = RPC_CANTRECV);
 		}
+	  free (cbuf);
 	}
 #endif
       do
