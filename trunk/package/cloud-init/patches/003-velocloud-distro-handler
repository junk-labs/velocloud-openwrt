diff -ruN cloud-init-0.7.9.orig//cloudinit/distros/velocloud.py cloud-init-0.7.9/cloudinit/distros/velocloud.py
--- cloud-init-0.7.9.orig//cloudinit/distros/velocloud.py	1970-01-01 00:00:00.000000000 +0000
+++ cloud-init-0.7.9/cloudinit/distros/velocloud.py	2017-07-17 20:17:38.000000000 +0000
@@ -0,0 +1,193 @@
+# vi: ts=4 expandtab
+#
+#    Copyright (C) 2012 Canonical Ltd.
+#    Copyright (C) 2012 Hewlett-Packard Development Company, L.P.
+#    Copyright (C) 2012 Yahoo! Inc.
+#
+#    Author: Scott Moser <scott.moser@canonical.com>
+#    Author: Juerg Haefliger <juerg.haefliger@hp.com>
+#    Author: Joshua Harlow <harlowja@yahoo-inc.com>
+#    Author: Ben Howard <ben.howard@canonical.com>
+#
+#    This program is free software: you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 3, as
+#    published by the Free Software Foundation.
+#
+#    This program is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+import os
+from cloudinit import distros
+from cloudinit import helpers
+from cloudinit import log as logging
+from cloudinit import util
+from cloudinit.net.network_state import parse_net_config_data
+
+from cloudinit.distros.parsers.hostname import HostnameConf
+
+from cloudinit.settings import PER_INSTANCE
+
+LOG = logging.getLogger(__name__)
+VCCONF = "/opt/vc/.edge.info"
+
+# network config is conforming to "Networking Config Version 1" 
+
+
+class Distro(distros.Distro):
+
+    init_cmd = []
+
+    def __init__(self, name, cfg, paths):
+        distros.Distro.__init__(self, name, cfg, paths)
+        self._runner = helpers.Runners(paths)
+        self.osfamily = 'velocloud'
+        cfg['ssh_svcname'] = '/etc/init.d/sshd'
+
+    def _is_vc_activated(self):
+        return os.path.exists(VCCONF)
+
+    def apply_locale(self, locale, out_fn=None):
+        raise NotImplementedError()
+
+    def install_packages(self, pkglist):
+        raise NotImplementedError()
+
+    def update_package_sources(self):
+        raise NotImplementedError()
+
+    def convert_eni_data(self, network_eni):
+        # do not modify network config on activated edge
+        if self._is_vc_activated():
+            return None
+        if type(network_eni) in (str, unicode):
+            return eni.convert_eni_data(network_eni)
+        if type(network_eni) != dict:
+            # ??
+            LOG.warn("Unknown type of data (%s) passed to convert_eni_data", str(type(network_eni)))
+            return None
+        configs = []
+        for iface_name, iface_conf in network_eni.iteritems():
+            if not iface_name.startswith('GE'):
+                LOG.warn("Only GE interfaces are supported (got '%s'). Skipping" % (iface_name))
+                continue
+            #subnet = copy.deepcopy(iface_conf)
+            subnettype = iface_conf.get('type')
+            if subnettype == 'dhcp':
+                subnet = {'type': 'dhcp'}
+            elif subnettype == 'static':
+                subnet = {'type': 'static',
+                          'address': iface_conf.get('ipaddr',''),
+                          'netmask': iface_conf.get('netmask',''),
+                          'gateway': iface_conf.get('gateway','-')}
+            else:
+                LOG.warn("Invalid addressing type for %s: %s. Skipping", iface_name, subnettype)
+                continue
+            config = {'type': 'physical',
+                      'name': iface_name,
+                      'subnets': [subnet]}
+            configs.append(config)
+        if configs:
+            return {'version': 1, 'config': configs}
+        return None
+
+    def _write_network_config(self, netconfig):
+        # do not modify network config on activated edge
+        if self._is_vc_activated():
+            return []
+
+        ns = parse_net_config_data(netconfig)
+        for iface in ns.iter_interfaces():
+            iface_name = iface['name']
+            iface_type = iface['type']
+            if iface_type != 'physical':
+                LOG.warn("Unsupported interface type '%s' for '%s'. Skipping" % (iface_type, iface_name))
+                continue
+            if not iface_name.startswith('GE'):
+                LOG.warn("Only GE interfaces are supported (got '%s'). Skipping" % (iface_name))
+                continue
+
+            iface_subnets = iface.get("subnets", [])
+            for subnet in iface_subnets:
+                cmd_wan_config = ["/opt/vc/bin/set_wan_config.sh", iface_name]
+                subnet_type = subnet.get('type')
+                if subnet_type in ['dhcp4', 'dhcp']:
+                    cmd_wan_config.append("DHCP")
+                elif subnet_type == 'static':
+                    ipaddr = subnet.get('address', '')
+                    netmask = subnet.get('netmask', '')
+                    gateway = subnet.get('gateway', '-')
+                    cmd_wan_config.extend(("STATIC", ipaddr, netmask, gateway))
+                else:
+                    err = "Unupported subnet type '%s' for '%s'" % (subnet_type, iface_name)
+                    LOG.error(err)
+                    raise ValueError(err)
+                util.subp(cmd_wan_config)
+
+        return []
+
+    def _write_network(self, settings):
+        raise NotImplementedError()
+
+    def _select_hostname(self, hostname, fqdn):
+        if not hostname:
+            return fqdn
+        return hostname
+
+    def _write_hostname(self, your_hostname, out_fn):
+        # uci set system.@system[0].hostname=<your_hostname>
+        # uci commit system
+        cmd_set = ['uci', 'set', 'system.@system[0].hostname='+your_hostname]
+        cmd_commit = ['uci', 'commit', 'system']
+
+        try:
+                util.subp(cmd_set)
+                util.subp(cmd_commit)
+        except IOError:
+                pass
+        return
+
+    def _read_hostname(self, filename, default=None):
+        hostname = None
+        try:
+            hostname = self._read_system_hostname()
+        except IOError:
+            pass
+        if not hostname:
+            return default
+        return hostname
+
+    def _read_system_hostname(self):
+        # Read from UCI
+        # uci get system.@system[0].hostname
+        sys_hostname = None
+        cmd = ['uci', 'get', 'system.@system[0].hostname']
+        try:
+            (sys_hostname, _err) = util.subp(cmd)
+        except IOError:
+            pass
+        except Exception as e:
+            raise e
+
+        if not sys_hostname:
+                return None
+
+        return sys_hostname
+
+    def _get_localhost_ip(self):
+        return "127.0.0.1"
+
+    def set_timezone(self, tz):
+        raise NotImplementedError()
+
+    def package_command(self, command, args=None, pkgs=None):
+        raise NotImplementedError()
+
+    def generate_fallback_config(self):
+        return None
+
+
