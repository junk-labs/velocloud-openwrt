diff -u a/mss_2013_10_31_33895/src/ipsec/ipsec.c b/mss_2013_10_31_33895/src/ipsec/ipsec.c
--- a/mss_2013_10_31_33895/src/ipsec/ipsec.c	2014-06-05 18:36:57.000000000 -0700
+++ b/mss_2013_10_31_33895/src/ipsec/ipsec.c	2014-07-05 18:06:42.494269143 -0700
@@ -4598,3 +4598,330 @@
 
 #endif /* defined(__ENABLE_MOCANA_IPSEC_SERVICE__) */
 
+/***********************************************************
+ * Velocloud private functions
+ **********************************************************/
+/* Doc Note: This function is for Velocloud internal code use only, and should
+ * not be included in the API documentation.
+ */
+
+/* 
+ * Get AuthKey from the given SADB
+ */
+extern sbyte4
+IPSEC_getAuthKey(void *pxSa, ubyte *poAuthKey/*[IPSEC_AUTHKEY_MAX]*/)
+{
+	SADB_hmacSuiteInfo* pHmacSuite;
+
+	if (!pxSa || !poAuthKey) return ERR_IPSEC_DROP_GETSA_FAIL;
+
+	/* get auth. key */
+	pHmacSuite = ((SADB)pxSa)->pHmacSuite;
+	if (!pHmacSuite) return ERR_IPSEC_DROP_GETSA_FAIL;
+
+	ubyte2 wAuthKeyLen = pHmacSuite->wKeyLen;
+	MOC_MEMCPY(poAuthKey, ((SADB)pxSa)->poAuthKey, wAuthKeyLen);
+
+	return OK;
+} /* IPSEC_getAuthKey */
+
+/* 
+ * Get the hmac ICV for the given payload with the given SADB
+ */
+extern sbyte4
+IPSEC_hmacICV(void *pxSa,
+	      ubyte *poPayload, ubyte2 wPayloadLen,
+	      ubyte *poAuthKey/*[IPSEC_AUTHKEY_MAX]*/,
+	      ubyte *poDigest/*[IPSEC_DIGEST_MAX]*/)
+{
+	MSTATUS     status;
+	SADB_hmacSuiteInfo* pHmacSuite;
+
+	if (!pxSa || !poPayload || !poAuthKey || !poDigest)
+		return ERR_IPSEC_DROP_GETSA_FAIL;
+
+	pHmacSuite = ((SADB)pxSa)->pHmacSuite;
+	if (!pHmacSuite) return ERR_IPSEC_DROP_GETSA_FAIL;
+
+	/* authenticate the esp payload */
+	/* calculate ICV for esp payload except Auth field */
+	if (OK != (status = pHmacSuite->hmacFunc(MOC_HASH(hwAccelCtx)
+						 poAuthKey,
+						 pHmacSuite->wKeyLen,
+						 poPayload, wPayloadLen,
+						 poDigest)))
+		EXIT_IPSEC;
+
+exit:
+
+	return (sbyte4)status;
+} /* IPSEC_hmacICV */
+
+/* 
+ * Append the ICV to the end of Payload & update IP header
+ */
+extern sbyte4
+IPSEC_hmacAppendICV(ubyte *poHdr, ubyte2 *pwLength,
+		    ubyte *poPayload, ubyte2 wPayloadLen,
+		    ubyte *poDigest/*[IPSEC_DIGEST_MAX]*/,
+		    ubyte2 wIcvLen)
+{
+	struct ipHdr *pxHdr = NULL;
+	ubyte2 wLength = *pwLength;
+
+	if (!poHdr || !poPayload || !poDigest) return ERR_IPSEC_DROP_GETSA_FAIL;
+
+	/* authenticate the payload */
+	/* append ICV at the end of packet */
+	MOC_MEMCPY(poPayload + wPayloadLen, poDigest, wIcvLen);
+
+	wLength += wIcvLen;
+	pxHdr = (struct ipHdr *)poHdr;
+	SET_HTONS(pxHdr->ip_len, wLength);
+
+	*pwLength = wLength;
+
+	return OK;
+} /* IPSEC_hmacAppendICV */
+
+/* 
+ * Get the SADB from the outbound packet
+ */
+extern sbyte4
+IPSEC_getSaOutbnd(ubyte *pBuffer, ubyte2 wBufSize, ubyte2 *pwOffset, IPSECCTX ctx,
+		  void **ppxSa)
+{
+	MSTATUS status = OK;
+	ubyte2 wOffset;
+	ubyte *poHdr;
+	struct ipHdr *pxHdr = NULL;
+	ubyte2 wHdrLen;
+	ubyte2 wLength;
+	ubyte  oProtocol;
+	ubyte *poPayload;
+	ubyte2 wPayloadLen;
+	MOC_IP_ADDRESS_S dwDestAddr, dwSrcAddr;
+	ubyte2 wDestPort, wSrcPort;
+#ifdef CUSTOM_IPSEC_FILTER_DSCP
+	ubyte oDscp;
+#endif
+	intBoolean bFragOff, bMoreFrags;
+#ifndef __DISABLE_IPSEC_TUNNEL_MODE__
+	MOC_IP_ADDRESS dwTunlDestIP, dwTunlSrcIP;
+#endif
+#ifdef __ENABLE_IPSEC_NAT_T__
+	ubyte2 wUdpEncPort;
+#endif
+
+	SPD pxSP = (NULL != ctx) ? ctx->pxSp : NULL;
+
+	/* store applied nested SA's */
+	SADB axSaUsed[IPSEC_NEST_MAX] = { NULL };
+
+#ifdef __ENABLE_IPSEC_INTERFACE_ID__
+	sbyte4 ifid = (NULL != ctx) ? ctx->ifid : 0;
+#endif
+#ifdef USE_MOC_COOKIE
+	ubyte4 cookie = (NULL != ctx) ? ctx->cookie : 0;
+#endif
+
+
+	if (NULL != ctx)
+		axSaUsed[0] = ctx->axSaUsed[0];
+
+	wOffset = (pwOffset ? *pwOffset : 0);
+	poHdr = pBuffer + wOffset;
+
+	/* get ip packet info */
+	if ((1 + wOffset) > wBufSize)
+	{
+		status = ERR_IPSEC_BUFFER_OVERFLOW;
+		EXIT_IPSEC;
+	}
+
+	/* check IP version */
+	switch (poHdr[0] & 0xF0)
+	{
+	case 0x40:
+		pxHdr = (struct ipHdr *)poHdr;
+		GET_PKT_INFO_OUT(pxHdr, (wBufSize - wOffset),
+				 wLength, wHdrLen, oProtocol, bFragOff, bMoreFrags);
+
+		SET_MOC_IPADDR4(dwSrcAddr,  GET_NTOHL(pxHdr->ip_src));
+		SET_MOC_IPADDR4(dwDestAddr, GET_NTOHL(pxHdr->ip_dst));
+
+#ifdef CUSTOM_IPSEC_FILTER_DSCP
+		oDscp = pxHdr->ip_tos;
+#endif
+		break;
+	default :
+		status = ERR_IPSEC_BAD_IP;
+		EXIT_IPSEC;
+		/*break;*/
+	}
+
+	poPayload   = poHdr + wHdrLen;
+	wPayloadLen = wLength - wHdrLen;
+
+	/* get SP and SA bundle for this packet */
+	GET_ULP_PORTS(poPayload, wPayloadLen, oProtocol, bFragOff,
+		      wDestPort, wSrcPort);
+
+	if (OK > (status = IPSEC_get(REF_MOC_IPADDR(dwDestAddr),
+				     REF_MOC_IPADDR(dwSrcAddr),
+				     oProtocol,
+				     bFragOff, bMoreFrags,
+				     poPayload, wPayloadLen,
+				     wDestPort, wSrcPort,
+#ifdef CUSTOM_IPSEC_FILTER_DSCP
+				     oDscp,
+#endif
+#ifndef __DISABLE_IPSEC_TUNNEL_MODE__
+				     &dwTunlDestIP, &dwTunlSrcIP,
+#endif
+#ifdef __ENABLE_IPSEC_NAT_T__
+				     &wUdpEncPort,
+#endif
+				     &pxSP, axSaUsed
+				     MOC_INTF_ID(ifid)
+				     MOC_COOKIE_VALUE(cookie))))
+	{
+		/* Bypass ICMPv6 Neighbor Discovery (RFC2461) message, if applicable.
+		   IKE (IPv6) traffic does not go through if these messges fail!
+		*/
+		if (STATUS_IPSEC_BYPASS != status) {
+			EXIT_IPSEC;
+		} else {
+			goto exit;
+		}
+	}
+
+	if (IPSEC_MODE_TUNNEL == pxSP->oMode) /* tunnel mode */
+	{
+		/* it should not be tunnel mode */
+		status = ERR_IPSEC_BAD_IP;
+		EXIT_IPSEC;
+	}
+
+	*ppxSa = (void *)axSaUsed[0];
+	status = OK;
+
+exit:
+
+	return (sbyte4)status;
+} /* IPSEC_getSaOutbnd */
+
+/* 
+ * Get the SADB from the inbound packet
+ */
+extern sbyte4
+IPSEC_getSaInbnd(ubyte *pBuffer, ubyte2 wBufSize, ubyte2 *pwOffset, IPSECCTX ctx,
+		 ubyte2 wVCMPHdrLen, void **ppxSa)
+{
+	MSTATUS status = OK;
+	ubyte *poHdr;
+	struct ipHdr *pxHdr = NULL;
+	ubyte2 wHdrLen;
+	ubyte2 wLength = 0;
+	ubyte  oProtocol;
+	MOC_IP_ADDRESS_S dwDestAddr, dwSrcAddr;
+	intBoolean bFragOff, bMoreFrags;
+	SADB pxSa;
+	ubyte4 dwSpi = 0;
+
+
+	poHdr = pBuffer;
+	/* get ip packet info */
+	if (1 > wBufSize)
+	{
+		status = ERR_IPSEC_BAD_IP;
+		EXIT_IPSEC;
+	}
+
+	/* check IP version */
+	switch (poHdr[0] & 0xF0)
+	{
+	case 0x40 :
+		pxHdr = (struct ipHdr *)poHdr;
+		GET_PKT_INFO_IN(pxHdr, wBufSize,
+				wLength, wHdrLen, oProtocol, bFragOff, bMoreFrags);
+		SET_MOC_IPADDR4(dwSrcAddr,  GET_NTOHL(pxHdr->ip_src));
+		SET_MOC_IPADDR4(dwDestAddr, GET_NTOHL(pxHdr->ip_dst));
+		break;
+
+	default :
+		status = ERR_IPSEC_BAD_IP;
+		EXIT_IPSEC;
+		/*break;*/
+	}
+
+	if (bFragOff) {
+		status = ERR_IPSEC_BAD_IP;
+		EXIT_IPSEC;
+	}
+	if (bMoreFrags) /* fragmented esp/ah */
+	{
+		status = ERR_IPSEC_FRAGMENTATION;
+		EXIT_IPSEC;
+	}
+
+
+	/* Special handling: Encryption payload only cover user data;
+	 * exclude VCMP header */
+	ubyte *poPayload;
+	ubyte2 wPayloadLen;
+	poPayload   = poHdr + wHdrLen + sizeof(struct udpHdr) + wVCMPHdrLen;
+	wPayloadLen = wLength - wHdrLen - sizeof(struct udpHdr) - wVCMPHdrLen;
+
+	/* oProtocol should match the tunnel we setup */
+	oProtocol = IPPROTO_ESP;
+
+	/* get SPI */
+	if (wPayloadLen < sizeof(struct espHdr)/* 8 */)
+	{
+		status = ERR_IPSEC_BAD_ESP;
+		EXIT_IPSEC;
+	}
+	SET_NTOHL(dwSpi, ((struct espHdr *)poPayload)->dwSpi);
+
+	/* find SA */
+	if (OK > (status = IPSEC_findSa(dwSpi, REF_MOC_IPADDR(dwDestAddr),
+					REF_MOC_IPADDR(dwSrcAddr),
+					oProtocol,
+#if defined(__ENABLE_MOCANA_IKE_SERVER__) && defined(__IKE_MULTI_HOMING__)
+					TRUE,
+#endif
+					&pxSa)))
+	{
+		LOG_IPSEC_PERMIT_FAIL(status, oProtocol, dwSpi, pxSa);
+		goto exit;
+	}
+
+	*ppxSa = (void *)pxSa;
+	status = pxSa? OK: ERR_IPSEC_DROP_GETSA_FAIL;
+
+exit:
+
+	return (sbyte4)status;
+} /* IPSEC_getSaInbnd */
+
+extern MSTATUS
+IPSEC_CRYPTO_Process(const void *pAlgo, ubyte* keyMaterial, sbyte4 keyLength,
+		     ubyte* iv, ubyte* data, sbyte4 dataLength, sbyte4 encrypt)
+{
+	return CRYPTO_Process(MOC_SYM(hwAccelCtx)
+			      (const BulkEncryptionAlgo *)pAlgo,
+			      keyMaterial, keyLength, iv,
+			      data, dataLength, encrypt);
+}
+
+extern ubyte4 
+IPSEC_CRYPTO_blockSize(void *pCipherSuite)
+{
+	if ((pCipherSuite == NULL) ||
+	    (((SADB_cipherSuiteInfo *)pCipherSuite)->pBEAlgo == NULL))
+		return 0;
+
+	return ((SADB_cipherSuiteInfo *)pCipherSuite)->pBEAlgo->blockSize;
+}
+
diff -u a/mss_2013_10_31_33895/src/ipsec/ipsec.h b/mss_2013_10_31_33895/src/ipsec/ipsec.h
--- a/mss_2013_10_31_33895/src/ipsec/ipsec.h	2013-11-08 11:39:19.000000000 -0800
+++ b/mss_2013_10_31_33895/src/ipsec/ipsec.h	2014-07-03 14:33:56.024607704 -0700
@@ -171,6 +171,26 @@
 MOC_EXTERN sbyte4 IPSEC_permitEx(ubyte *pBuffer, ubyte2 wBufSize,
                                  ubyte2 *pwLength, ubyte2 *pwOffset,
                                  struct ipsecCtx *ctx);
+extern sbyte4 IPSEC_getAuthKey(void *pxSa,
+			       ubyte *poAuthKey/*[IPSEC_AUTHKEY_MAX]*/);
+extern sbyte4 IPSEC_hmacICV(void *pxSa,
+			    ubyte *poPayload, ubyte2 wPayloadLen,
+			    ubyte *poAuthKey/*[IPSEC_AUTHKEY_MAX]*/,
+			    ubyte *poDigest/*[IPSEC_DIGEST_MAX]*/);
+extern sbyte4 IPSEC_hmacAppendICV(ubyte *poHdr, ubyte2 *pwLength,
+				  ubyte *poPayload, ubyte2 wPayloadLen,
+				  ubyte *poDigest/*[IPSEC_DIGEST_MAX]*/,
+				  ubyte2 wIcvLen);
+extern sbyte4 IPSEC_getSaOutbnd(ubyte *pBuffer, ubyte2 wBufSize,
+				ubyte2 *pwOffset, struct ipsecCtx *ctx,
+				void **ppxSa);
+extern sbyte4 IPSEC_getSaInbnd(ubyte *pBuffer, ubyte2 wBufSize,
+			       ubyte2 *pwOffset, struct ipsecCtx *ctx,
+			       ubyte2 wVCMPHdrLen, void **ppxSa);
+extern MSTATUS IPSEC_CRYPTO_Process(const void *pAlgo, ubyte* keyMaterial,
+				    sbyte4 keyLength, ubyte* iv, ubyte* data,
+				    sbyte4 dataLength, sbyte4 encrypt);
+extern ubyte4 IPSEC_CRYPTO_blockSize(void *pCipherSuite);
 
 
 /*------------------------------------------------------------------*/
