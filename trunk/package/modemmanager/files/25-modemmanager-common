#!/bin/sh
# Copyright (C) 2016 Velocloud Inc

MODEMMANAGER_BLACKLIST=/etc/modemmanager/modemmanager.blacklist
MODEMMANAGER_EVENTS_CACHE=/tmp/ModemManager.events
MODEMMANAGER_CDCWDM_CACHE=/tmp/ModemManager.cdcwdm

################################################################################
# Common logging

mm_log() {
	logger -t "ModemManager" "hotplug: $@"
}

################################################################################
# Receives as input argument the full sysfs path of the device
# Returns the physical device sysfs path

mm_find_physdev_sysfs_path() {
	local tmp_path="$1"

	while [ 1 ]; do
		tmp_path=$(dirname ${tmp_path})

		# avoid infinite loops iterating
		[ -z "${tmp_path}" ] || [ "${tmp_path}" = "/" ] && return

		# the physical device will be that with a idVendor and idProduct pair of files
		[ -f ${tmp_path}/idVendor ] && [ -f ${tmp_path}/idProduct ] && {
			tmp_path=$(readlink -f $tmp_path)
			echo ${tmp_path}
			return
		}
	done
}

################################################################################

# Receives as input argument the full sysfs path of the device
# Returns the reason for being blacklisted
mm_check_modemmanager_blacklist() {
	local sysfs_path="$1"

	local vid
	local pid
	local conf
	local full_entry
	local other_entries
	local reason
	local physdev_sysfs_path

	physdev_sysfs_path=$(mm_find_physdev_sysfs_path ${sysfs_path})
	[ -z "${physdev_sysfs_path}" ] && {
		echo "couldn't get physical device sysfs path"
		return
	}

	vid=$(cat ${physdev_sysfs_path}/idVendor)
	pid=$(cat ${physdev_sysfs_path}/idProduct)
	[ -z "${vid}" ] || [ -z "${pid}" ] && {
		echo "couldn't get physical device vid:pid"
		return
	}

	conf=$(cat ${physdev_sysfs_path}/bConfigurationValue)
	[ -z "${conf}" ] && {
		echo "couldn't get physical device usb configuration"
		return
	}

	# Check if the vid:pid:conf entry is in the blacklist"
	full_entry=$(awk -v prod="$vid:$pid:$conf" '!/^#/ && $0 ~ prod { print $0 }' $MODEMMANAGER_BLACKLIST)
	[ -z "$full_entry" ] && {
		# If the match with usb configuration isn't in the blacklist, check if
		# there is some other entry in the list with some other configuration
		# value blacklisted
		other_entries=$(awk -v prod="$vid:$pid:" '!/^#/ && $0 ~ prod { print $0 }' $MODEMMANAGER_BLACKLIST)

		# Some other usb configuration is blacklisted, not the one we have
		[ -n "$other_entries" ] && return

		# Look for a match without explicit usb configuration
		full_entry=$(awk -v prod="$vid:$pid" '!/^#/ && $0 ~ prod { print $0 }' $MODEMMANAGER_BLACKLIST)
	}

	# Not blacklisted?
	[ -z "$full_entry" ] && return

	# If it is, get the reason for the blacklisting
	reason=$(echo $full_entry | awk '{ $1=""; print $0 }')
	[ -n "$reason" ] && {
		echo "$reason"
		return
	}

	echo "unknown reason"
}

################################################################################

# Returns the cdc-wdm name retrieved from sysfs
mm_track_cdcwdm() {
	local wwan="$1"
	local cdcwdm

	cdcwdm=$(ls "/sys/class/net/${wwan}/device/usbmisc/")
	[ -n "${cdcwdm}" ] || return

	# We have to cache it for later, as we won't be able to get the
	# associated cdc-wdm device on a remove event
	echo "${wwan} ${cdcwdm}" >> "${MODEMMANAGER_CDCWDM_CACHE}"

	echo "${cdcwdm}"
}

# Returns the cdc-wdm name retrieved from the cache
mm_untrack_cdcwdm() {
	local wwan="$1"
	local cdcwdm

	# Look for the cached associated cdc-wdm device
	[ -f "${MODEMMANAGER_CDCWDM_CACHE}" ] || return

	cdcwdm=$(awk -v wwan="${wwan}" '!/^#/ && $0 ~ wwan { print $2 }' "${MODEMMANAGER_CDCWDM_CACHE}")
	[ -n "${cdcwdm}" ] || return

	# Remove from cache
	sed -i "/${wwan} ${cdcwdm}/d" "${MODEMMANAGER_CDCWDM_CACHE}"

	echo "${cdcwdm}"
}

################################################################################
# Event reporting

# Receives as input the action, the device name and the subsystem
mm_report_event() {
	local action=$1
	local name=$2
	local subsystem=$3

	# Track/untrack events in cache
	case "${action}" in
		"add")
			# On add events, store event details in cache
			echo "action=${action},name=${name},subsystem=${subsystem}" >> "${MODEMMANAGER_EVENTS_CACHE}"
			;;
		"remove")
			# On remove events, remove old events from cache (match by subsystem+name)
			sed -i "/name=${name},subsystem=${subsystem}/d" "${MODEMMANAGER_EVENTS_CACHE}"
			;;
	esac

	# Report the event
	mm_log "event reported: action=${action}, name=${name}, subsystem=${subsystem}"
	/usr/bin/mmcli --report-kernel-event="action=${action},name=${name},subsystem=${subsystem}" 1>/dev/null 2>&1 &
}
