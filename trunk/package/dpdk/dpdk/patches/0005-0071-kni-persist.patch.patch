From 948b45a9624984a9382c0e73dbe7443969a514cd Mon Sep 17 00:00:00 2001
From: "egorovv@gmail.com" <egorovv@gmail.com>
Date: Mon, 6 Mar 2017 14:56:19 -0800
Subject: [PATCH 5/7] 0071-kni-persist.patch

--
---
 .../linuxapp/eal/include/exec-env/rte_kni_common.h |   1 +
 lib/librte_eal/linuxapp/kni/kni_dev.h              |   6 +
 lib/librte_eal/linuxapp/kni/kni_misc.c             | 128 ++++++++++++++++-----
 lib/librte_eal/linuxapp/kni/kni_net.c              |  37 ++++++
 lib/librte_kni/rte_kni.c                           |   1 +
 lib/librte_kni/rte_kni.h                           |   3 +
 6 files changed, 145 insertions(+), 31 deletions(-)

diff --git a/lib/librte_eal/linuxapp/eal/include/exec-env/rte_kni_common.h b/lib/librte_eal/linuxapp/eal/include/exec-env/rte_kni_common.h
index 09713b0..7343be3 100644
--- a/lib/librte_eal/linuxapp/eal/include/exec-env/rte_kni_common.h
+++ b/lib/librte_eal/linuxapp/eal/include/exec-env/rte_kni_common.h
@@ -166,6 +166,7 @@ struct rte_kni_device_info {
 
 	__extension__
 	uint8_t force_bind : 1;       /**< Flag for kernel thread binding */
+    uint8_t persist_on_close : 1; /**< Dont delete interface on dev/kni close */
 
 	/* mbuf size */
 	unsigned mbuf_size;
diff --git a/lib/librte_eal/linuxapp/kni/kni_dev.h b/lib/librte_eal/linuxapp/kni/kni_dev.h
index 58cbadd..6cda52b 100644
--- a/lib/librte_eal/linuxapp/kni/kni_dev.h
+++ b/lib/librte_eal/linuxapp/kni/kni_dev.h
@@ -102,6 +102,12 @@ struct kni_dev {
 	/* synchro for request processing */
 	unsigned long synchro;
 
+    /* Persist netdev on /dev/kni close */
+    uint8_t netdev_persist : 1;
+
+    /* /dev/kni is closed or not */
+    uint8_t kni_released : 1;
+
 #ifdef RTE_KNI_VHOST
 	struct kni_vhost_queue *vhost_queue;
 
diff --git a/lib/librte_eal/linuxapp/kni/kni_misc.c b/lib/librte_eal/linuxapp/kni/kni_misc.c
index 497db9b..6063c38 100644
--- a/lib/librte_eal/linuxapp/kni/kni_misc.c
+++ b/lib/librte_eal/linuxapp/kni/kni_misc.c
@@ -51,6 +51,32 @@ MODULE_DESCRIPTION("Kernel Module for managing kni devices");
 extern const struct pci_device_id ixgbe_pci_tbl[];
 extern const struct pci_device_id igb_pci_tbl[];
 
+extern void kni_net_rx(struct kni_dev *kni);
+extern void kni_net_init(struct net_device *dev);
+extern void kni_net_config_lo_mode(char *lo_str);
+extern void kni_net_poll_resp(struct kni_dev *kni);
+extern void kni_set_ethtool_ops(struct net_device *netdev);
+
+extern int ixgbe_kni_probe(struct pci_dev *pdev, struct net_device **lad_dev);
+extern void ixgbe_kni_remove(struct pci_dev *pdev);
+extern int igb_kni_probe(struct pci_dev *pdev, struct net_device **lad_dev);
+extern void igb_kni_remove(struct pci_dev *pdev);
+
+static int kni_open(struct inode *inode, struct file *file);
+static int kni_release(struct inode *inode, struct file *file);
+static int kni_ioctl(struct inode *inode, unsigned int ioctl_num,
+					unsigned long ioctl_param);
+static int kni_compat_ioctl(struct inode *inode, unsigned int ioctl_num,
+						unsigned long ioctl_param);
+static int kni_dev_remove(struct kni_dev *dev, int netdev_remove);
+
+static int __init kni_parse_kthread_mode(void);
+
+/* KNI processing for single kernel thread mode */
+static int kni_thread_single(void *unused);
+/* KNI processing for multiple kernel thread mode */
+static int kni_thread_multiple(void *param);
+
 /* loopback mode */
 static char *lo_mode;
 
@@ -110,9 +136,22 @@ kni_init_net(struct net *net)
 static void __net_exit
 kni_exit_net(struct net *net)
 {
-	struct kni_net *knet __maybe_unused;
-
-	knet = net_generic(net, kni_net_id);
+	struct kni_net *knet = net_generic(net, kni_net_id);
+        struct kni_dev *dev, *n;
+
+        /*
+         * Remove all the persistent KNI interfaces.
+         */
+        down_write(&knet->kni_list_lock);
+        list_for_each_entry_safe(dev, n, &knet->kni_list_head, list) {
+                if (dev->net_dev) {
+                        unregister_netdev(dev->net_dev);
+                        free_netdev(dev->net_dev);
+                }
+                list_del(&dev->list);
+        }
+        up_write(&knet->kni_list_lock);
+   
 	mutex_destroy(&knet->kni_kthread_lock);
 
 #ifndef HAVE_SIMPLIFIED_PERNET_OPERATIONS
@@ -200,7 +239,7 @@ kni_open(struct inode *inode, struct file *file)
 }
 
 static int
-kni_dev_remove(struct kni_dev *dev)
+kni_dev_remove(struct kni_dev *dev, int netdev_remove)
 {
 	if (!dev)
 		return -ENODEV;
@@ -212,7 +251,7 @@ kni_dev_remove(struct kni_dev *dev)
 			igb_kni_remove(dev->pci_dev);
 	}
 
-	if (dev->net_dev) {
+	if (dev->net_dev && netdev_remove) {
 		unregister_netdev(dev->net_dev);
 		free_netdev(dev->net_dev);
 	}
@@ -249,8 +288,12 @@ kni_release(struct inode *inode, struct file *file)
 #ifdef RTE_KNI_VHOST
 		kni_vhost_backend_release(dev);
 #endif
-		kni_dev_remove(dev);
-		list_del(&dev->list);
+		kni_dev_remove(dev, !dev->netdev_persist);
+		if (!dev->netdev_persist) {
+			list_del(&dev->list);
+		} else {
+			dev->kni_released = 1;
+		}
 	}
 	up_write(&knet->kni_list_lock);
 
@@ -289,7 +332,7 @@ kni_run_thread(struct kni_net *knet, struct kni_dev *kni, uint8_t force_bind)
 		kni->pthread = kthread_create(kni_thread_multiple,
 			(void *)kni, "kni_%s", kni->name);
 		if (IS_ERR(kni->pthread)) {
-			kni_dev_remove(kni);
+			kni_dev_remove(kni, 1);
 			return -ECANCELED;
 		}
 
@@ -304,7 +347,7 @@ kni_run_thread(struct kni_net *knet, struct kni_dev *kni, uint8_t force_bind)
 				(void *)knet, "kni_single");
 			if (IS_ERR(knet->kni_kthread)) {
 				mutex_unlock(&knet->kni_kthread_lock);
-				kni_dev_remove(kni);
+				kni_dev_remove(kni, 1);
 				return -ECANCELED;
 			}
 
@@ -330,7 +373,8 @@ kni_ioctl_create(struct net *net, uint32_t ioctl_num,
 	struct pci_dev *found_pci = NULL;
 	struct net_device *net_dev = NULL;
 	struct net_device *lad_dev = NULL;
-	struct kni_dev *kni, *dev, *n;
+	struct kni_dev *kni = NULL, *dev, *n;
+	int kni_exists = 0;
 
 	pr_info("Creating kni...\n");
 	/* Check the buffer size, to avoid warning */
@@ -356,25 +400,41 @@ kni_ioctl_create(struct net *net, uint32_t ioctl_num,
 	down_read(&knet->kni_list_lock);
 	list_for_each_entry_safe(dev, n, &knet->kni_list_head, list) {
 		if (kni_check_param(dev, &dev_info) < 0) {
-			up_read(&knet->kni_list_lock);
-			return -EINVAL;
+			kni = dev;
+			kni_exists = 1;
+			break;
 		}
 	}
 	up_read(&knet->kni_list_lock);
 
-	net_dev = alloc_netdev(sizeof(struct kni_dev), dev_info.name,
+	if (kni_exists && !dev_info.persist_on_close) {
+		return -EINVAL;
+	}
+
+	if (!kni_exists) {
+		net_dev = alloc_netdev(sizeof(struct kni_dev), dev_info.name,
 #ifdef NET_NAME_UNKNOWN
-							NET_NAME_UNKNOWN,
+				       NET_NAME_UNKNOWN,
 #endif
-							kni_net_init);
-	if (net_dev == NULL) {
-		pr_err("error allocating device \"%s\"\n", dev_info.name);
-		return -EBUSY;
+				       kni_net_init);
+		if (net_dev == NULL) {
+			pr_err("error allocating device \"%s\"\n", dev_info.name);
+			return -EBUSY;
+		}
+	} else {
+		net_dev = kni->net_dev;
 	}
 
 	dev_net_set(net_dev, net);
 
-	kni = netdev_priv(net_dev);
+	if (!kni_exists) {
+		kni = netdev_priv(net_dev);
+	}
+	if (dev_info.persist_on_close) {
+		kni->netdev_persist = 1;
+	} else {
+		kni->netdev_persist = 0;
+	}
 
 	kni->net_dev = net_dev;
 	kni->group_id = dev_info.group_id;
@@ -469,14 +529,16 @@ kni_ioctl_create(struct net *net, uint32_t ioctl_num,
 		 */
 		random_ether_addr(net_dev->dev_addr);
 
-	ret = register_netdev(net_dev);
-	if (ret) {
-		pr_err("error %i registering device \"%s\"\n",
-					ret, dev_info.name);
-		kni->net_dev = NULL;
-		kni_dev_remove(kni);
-		free_netdev(net_dev);
-		return -ENODEV;
+	if (!kni_exists) {
+		ret = register_netdev(net_dev);
+		if (ret) {
+			pr_err("error %i registering device \"%s\"\n",
+			       ret, dev_info.name);
+			kni->net_dev = NULL;
+			kni_dev_remove(kni, 1);
+			free_netdev(net_dev);
+			return -ENODEV;
+		}
 	}
 
 #ifdef RTE_KNI_VHOST
@@ -487,9 +549,13 @@ kni_ioctl_create(struct net *net, uint32_t ioctl_num,
 	if (ret != 0)
 		return ret;
 
-	down_write(&knet->kni_list_lock);
-	list_add(&kni->list, &knet->kni_list_head);
-	up_write(&knet->kni_list_lock);
+	if (!kni_exists) {
+		down_write(&knet->kni_list_lock);
+		list_add(&kni->list, &knet->kni_list_head);
+		up_write(&knet->kni_list_lock);
+	} else {
+		kni->kni_released = 0;
+	}
 
 	return 0;
 }
@@ -529,7 +595,7 @@ kni_ioctl_release(struct net *net, uint32_t ioctl_num,
 #ifdef RTE_KNI_VHOST
 		kni_vhost_backend_release(dev);
 #endif
-		kni_dev_remove(dev);
+		kni_dev_remove(dev, 1);
 		list_del(&dev->list);
 		ret = 0;
 		break;
diff --git a/lib/librte_eal/linuxapp/kni/kni_net.c b/lib/librte_eal/linuxapp/kni/kni_net.c
index 4ac99cf..d1ec924 100644
--- a/lib/librte_eal/linuxapp/kni/kni_net.c
+++ b/lib/librte_eal/linuxapp/kni/kni_net.c
@@ -151,6 +151,10 @@ kni_net_open(struct net_device *dev)
 	struct rte_kni_request req;
 	struct kni_dev *kni = netdev_priv(dev);
 
+    if (kni->kni_released) {
+        return -EAGAIN;
+    }
+
 	netif_start_queue(dev);
 
 	memset(&req, 0, sizeof(req));
@@ -170,6 +174,10 @@ kni_net_release(struct net_device *dev)
 	struct rte_kni_request req;
 	struct kni_dev *kni = netdev_priv(dev);
 
+    if (kni->kni_released) {
+        return -EAGAIN;
+    }
+
 	netif_stop_queue(dev); /* can't transmit any more */
 
 	memset(&req, 0, sizeof(req));
@@ -204,6 +212,10 @@ kni_net_tx(struct sk_buff *skb, struct net_device *dev)
 {
 	struct kni_dev *kni = netdev_priv(dev);
 
+	if (kni->kni_released) {
+		return NETDEV_TX_BUSY;
+	}
+
 	dev_kfree_skb(skb);
 	kni->stats.tx_dropped++;
 
@@ -220,6 +232,10 @@ kni_net_tx(struct sk_buff *skb, struct net_device *dev)
 	void *pkt_pa = NULL;
 	void *pkt_va = NULL;
 
+	if (kni->kni_released) {
+		return NETDEV_TX_BUSY;
+	}
+
 	/* save the timestamp */
 #ifdef HAVE_TRANS_START_HELPER
 	netif_trans_update(dev);
@@ -558,6 +574,10 @@ kni_net_rx_lo_fifo_skb(struct kni_dev *kni)
 void
 kni_net_rx(struct kni_dev *kni)
 {
+	if (kni->kni_released) {
+		return;
+	}
+
 	/**
 	 * It doesn't need to check if it is NULL pointer,
 	 * as it has a default value
@@ -573,6 +593,10 @@ kni_net_tx_timeout(struct net_device *dev)
 {
 	struct kni_dev *kni = netdev_priv(dev);
 
+	if (kni->kni_released) {
+		return;
+	}
+
 	pr_debug("Transmit timeout at %ld, latency %ld\n", jiffies,
 			jiffies - dev_trans_start(dev));
 
@@ -586,6 +610,12 @@ kni_net_tx_timeout(struct net_device *dev)
 static int
 kni_net_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
+	struct kni_dev *kni = netdev_priv(dev);
+
+	if (kni->kni_released) {
+		return -EAGAIN;
+	}
+
 	pr_debug("kni_net_ioctl group:%d cmd:%d\n",
 		((struct kni_dev *)netdev_priv(dev))->group_id, cmd);
 
@@ -604,6 +634,10 @@ kni_net_change_mtu(struct net_device *dev, int new_mtu)
 	struct rte_kni_request req;
 	struct kni_dev *kni = netdev_priv(dev);
 
+        if (kni->kni_released) {
+            return -EAGAIN;
+        }
+
 	pr_debug("kni_net_change_mtu new mtu %d to be set\n", new_mtu);
 
 	memset(&req, 0, sizeof(req));
@@ -622,6 +656,9 @@ kni_net_change_mtu(struct net_device *dev, int new_mtu)
 void
 kni_net_poll_resp(struct kni_dev *kni)
 {
+    if (kni->kni_released) {
+        return;
+    }
 	if (kni_fifo_count(kni->resp_q))
 		wake_up_interruptible(&kni->wq);
 }
diff --git a/lib/librte_kni/rte_kni.c b/lib/librte_kni/rte_kni.c
index bf955a8..b760ef8 100644
--- a/lib/librte_kni/rte_kni.c
+++ b/lib/librte_kni/rte_kni.c
@@ -365,6 +365,7 @@ rte_kni_alloc(struct rte_mempool *pktmbuf_pool,
 	dev_info.device_id = conf->id.device_id;
 	dev_info.core_id = conf->core_id;
 	dev_info.force_bind = conf->force_bind;
+    dev_info.persist_on_close = conf->persist_on_close;
 	dev_info.group_id = conf->group_id;
 	dev_info.mbuf_size = conf->mbuf_size;
 
diff --git a/lib/librte_kni/rte_kni.h b/lib/librte_kni/rte_kni.h
index 37deb47..e947977 100644
--- a/lib/librte_kni/rte_kni.h
+++ b/lib/librte_kni/rte_kni.h
@@ -72,6 +72,8 @@ struct rte_kni_ops {
 	int (*config_network_if)(uint8_t port_id, uint8_t if_up);
 };
 
+#define HAS_KNI_PERSIST_ON_CLOSE
+
 /**
  * Structure for configuring KNI device.
  */
@@ -90,6 +92,7 @@ struct rte_kni_conf {
 
 	__extension__
 	uint8_t force_bind : 1; /* Flag to bind kernel thread */
+    uint8_t persist_on_close : 1; /* Flag to keep KNI around post /dev/kni close */
 };
 
 /**
-- 
2.7.4

