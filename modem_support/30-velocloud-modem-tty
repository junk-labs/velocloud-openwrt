#!/bin/sh

# Copyright (C) 2013-2014 Velocloud Inc

usb_serial_detect() {
	local status=1
	local tries=0
	local device=$1
	while [ $status -ne 0 -a $tries -le 3 ]; do
		gcom -d "$device" -s /etc/gcom/vccheck.gcom | grep 'OK' &>/dev/null
		status=$?
		tries=$((tries + 1))
	done
	if [ $status -ne 0 ]; then
		# Not a serial port
		log "No output from device $device"
		return
	fi
	log "Detected device $device is found"
	echo $device
}

gettty_device() {
	local ttydevice=$DEVICENAME

	if [ ! -e /dev/$ttydevice ]; then
		log "Serial device does not exists... Waiting!"
		sleep 1
		# Wait for tty file exists
		if [ ! -e /dev/$ttydevice ]; then
			ttydevice=""
			return
		fi
	fi
	log "Device /dev/$ttydevice exists"

	ttydevice=$(usb_serial_detect "/dev/$ttydevice")
	echo $ttydevice
}

get_hw_details() {
	local dialdevice=$1
	local tempfile=$2
	local cardinfocmd="gcom -d $dialdevice -s /etc/gcom/vcgetcardinfo.gcom"
	local cardinfo_tries=3
	while [ ! -s $tempfile ] && [ "$cardinfo_tries" -ne 0 ]; do
		$cardinfocmd | awk 'NR>1 && $1 !~ /^OK$/ && $1 !~ /^$/ { print }' > $tempfile
		cardinfo_tries=$(expr $cardinfo_tries - 1)
	done
}

update_mgmt_config() {
	local mgmtdevice=$1
	uci -c $modem_path set modems.$usbifname.mgmt="$mgmtdevice"
	uci -c $modem_path commit modems
}

update_mgmt_device() {
	local mgmtdevice=$1
	uci -c $modem_path -X get modems.$usbifname.mgmt 2>&1 >/dev/null
	if [ "$?" != "0" ]; then
		update_mgmt_config "$mgmtdevice"
		log "Mgmt device $mgmtdevice updated"
	else
		log "Mgmt device already detected"
	fi
}

update_backup_user_config() {
	local product=$1
	local username="dummy"
	local password="dummy"
	local dialnumber="#777"

	touch $db_dir/$usbifname

	uci -c $db_dir add $usbifname interface\\\ '"$usbifname"'
	uci -c $db_dir set $usbifname.$usbifname=interface
	uci -c $db_dir set $usbifname.$usbifname.ifname=''"$usbifname"''
	uci -c $db_dir set $usbifname.$usbifname.dialnumber=''"$dialnumber"''
	uci -c $db_dir set $usbifname.$usbifname.username=''"$username"''
	uci -c $db_dir set $usbifname.$usbifname.password=''"$password"''
	uci -c $db_dir set $usbifname.$usbifname.status="Trying to connect ..."
	uci -c $db_dir set $usbifname.$usbifname.type='serial'
	uci -c $db_dir set $usbifname.$usbifname.product=''"$product"''
}

update_dialdevice_to_config() {
	local dialdevice=$1
	uci -c $db_dir set $usbifname.$usbifname.device="$dialdevice"
}

update_backup() {
	local variable=$1
	local value=$2
	uci -c $db_dir set $usbifname.$usbifname.$variable=''"$value"''
}

update_backup_hw_config() {
	local manufacturer=$1
	local model_number=$2
	local revision_number=$3
	local cdma_gsm=$4
	local linkid=$5

	uci -c $db_dir set $usbifname.$usbifname.manufacturer=''"$manufacturer"''
	uci -c $db_dir set $usbifname.$usbifname.modelnumber=''"$model_number"''
	uci -c $db_dir set $usbifname.$usbifname.revisionnumber=''"$revision_number"''
	uci -c $db_dir set $usbifname.$usbifname.cdmagsm=''"$cdma_gsm"''
	uci -c $db_dir set $usbifname.$usbifname.linkid=''"$linkid"''
}

uci_commit_backup() {
	uci -c $db_dir commit $usbifname
}

uci_import_modems_config() {
	uci -c $db_dir export $usbifname > /$tmpdir/modems.uci
	sed -i 's/package.*/package modems/' /$tmpdir/modems.uci
	uci -c $modem_path import -m modems < /$tmpdir/modems.uci
}

uci_dialdevice_modems_config() {
	local dialdevice=$1
	uci -c $modem_path set modems.$usbifname.device="$dialdevice"
}

uci_commit_modems() {
	local dialdevice=$1
	uci_import_modems_config
	uci_dialdevice_modems_config $dialdevice
	uci -c $modem_path commit modems
}

get_cdma_gsm() {
	local tempfile=$1
	local imei_number
	local cdma_gsm
	imei_number=$(awk '{if(match($0, "ESN:")) {for(i=2;i<=NF;i++) { printf $i" "};exit}}' $tempfile)
	if [ ! -z $imei_number ];then
		cdma_gsm="CDMA"
	else
		cdma_gsm="GSM"
	fi
	echo $cdma_gsm
}

get_imei_number() {
	local tempfile=$1
	local cdma_string=$(get_cdma_gsm $tempfile)
	local imei_number
	if [ $cdma_string == "GSM" ];then
		imei_number=$(awk '{if(match($0, "IMEI:")) {for(i=2;i<=NF;i++) { printf $i" "};exit}}' $tempfile)
	else
		imei_number=$(awk '{if(match($0, "ESN:")) {for(i=2;i<=NF;i++) { printf $i" "};exit}}' $tempfile)
	fi
	echo $imei_number
}

get_imsi_number() {
	local dialdevice=$1
	local imsi_tries=3
	local tempfile="$tmpdir/$usbifname.siminfo"
	local imsicmd="gcom -d $dialdevice -s /etc/gcom/vcgetimsi.gcom"
	local imsi_number
	while [ -z $imsi_number ] && [ "$imsi_tries" -ne 0 ]; do
		$imsicmd | awk 'NR>1 && $1 !~ /^OK$/ && $1 !~ /^$/ { print }' > $tempfile
		log "IMSI Info: $(cat $tempfile | xargs echo)"

		imsi_number=$(cat $tempfile | awk '{for(i=1;i<=NF;i++){ if(match($i, /[0-9]{14,15}$/)){print $i;break} } }')
		imsi_tries=$(expr $imsi_tries - 1)
	done
	log "IMSI: $imsi_number"
	rm -f $tempfile
	echo $imsi_number
}

get_linkid() {
	local imsi_number=$1
	local imei_number=$2
	local linkid

	if [ "$imsi_number" == "" ] || [ "$imsi_number" == "ERROR" ];then
		linkid=$imei_number
	else
		linkid=$imsi_number
	fi
	log "Linkid: $linkid, IMEI: $imei_number"
	echo $linkid
}

get_manufacturer() {
	local tempfile=$1
	echo $(awk '{if(match(tolower($0), "manufacturer")) {for(i=2;i<=NF;i++) { printf $i" "};exit}}' $tempfile)
}

get_model_number() {
	local tempfile=$1
	echo $(awk '{if(match(tolower($0), "model")) {for(i=2;i<=NF;i++) { printf $i" "};exit}}' $tempfile)
}

get_revision_number() {
	local tempfile=$1
	echo $(awk '{if(match(tolower($0), "revision")) {for(i=2;i<=NF;i++) { printf $i" "};exit}}' $tempfile)
}

update_hwinfo_config() {
	local tempfile="$tmpdir/$usbifname.cardinfo"
	local manufacturer model_number revision_number
	local cdma_string
	local cdma_gsm="CDMA"
	# If Electronic Signal Number is present then its CDMA
	local imei_number imsi_number
	# If ESN is present get the number after that for CDMA else get from IMEI for GSM

	get_hw_details $dialdevice $tempfile

	manufacturer=$(get_manufacturer $tempfile)
	model_number=$(get_model_number $tempfile)
	revision_number=$(get_revision_number $tempfile)
	imei_number=$(get_imei_number $tempfile)
	imsi_number=$(get_imsi_number $dialdevice)
	cdma_gsm=$(get_cdma_gsm $tempfile)

	log "Card Info: $(cat $tempfile | xargs echo)"
	rm -f $tempfile

	linkid=$(get_linkid "$imsi_number" "$imei_number")
	update_backup_hw_config "$manufacturer" "$model_number" "$revision_number" "$cdma_gsm" "$linkid"
}

update_dial_device() {
	local dialdevice=$1
	local product=$2

	update_backup_user_config $product
	update_hwinfo_config $dialdevice
	#update_dialdevice_to_config $dialdevice
	uci_commit_backup
	uci_commit_modems $dialdevice
}


start_pppd_script() {
	$modem_script_path/modem_service.sh $usbifname start 2>&1 >/dev/null &
}

# QMI hybrid modems are a pain in the butt, it can support data over
# qmi_wwan driver wwanX interface. But its control is all done over
# serial ttyUSB using AT commands. Later the 30-usb_ip script will call
# modem_service.sh as part of the hotplug event for the wwanX interface,
# and at that point we need to let the modem_service.sh script know which
# serial interface is the "control" interface for this mode, so we just
# set the mgmt device parameter here and call it a day, rest all gets
# done from 30-usb_ip
handle_qmi_hybrid() {
	local ttydevice
	local ifname

	ttydevice=$(gettty_device)
	if [ -z "$ttydevice" ]; then
		log "No TTY device: $usbpath"
		return
	fi

	count=1
	while [ $count -le 10 ];
	do
		imei=`gcom -d $ttydevice -s /etc/gcom/getimei.gcom | grep -E '[0-9]+'`
		if [ ! -z "$imei" ]; then
			break
		fi
		sleep 2
		count=$(($count+1))
	done

	# In qmi-hybrid modems we trigger the profile generation as soon as we get
	# the management TTY
	apn=$(at_get_apn $ttydevice $usbifname)
	PROFILE=/tmp/USB/${usbifname}.profile
	echo "APN=$apn" > ${PROFILE}

	lock $lockfile
	uci -c $modem_path add modems interface\\\ '"$usbifname"'
	uci -c $modem_path set modems.$usbifname=interface
	uci -c $modem_path set modems.$usbifname.device=''"$ttydevice"''
	uci -c $modem_path commit modems
	lock -u $lockfile

	log "DEVICE=$DEVICENAME: USBIF=$usbifname TTY=$ttydevice imei=$imei TYPE=qmihybrid"

	# If we have the WWAN net iface name already defined, we're ready to go;
	# otherwise we'll need to wait and it will get launched when the net iface
	# is processed.
	ifname=$(uci_get_modem_ifname $usbifname)
	if [ -z "$ifname" ]; then
		log "WWAN net not yet defined in qmihybrid modem: deferred"
		return
	fi

	log "WWAN modem setup: QMI-hybrid"
	$modem_script_path/modem_service.sh $usbifname start
}

# Sierra Direct IP devices are controlled through AT commands in a TTY,
# while the data goes through the WWAN exposed with the sierra_net kernel
# driver. Later the 30-usb_ip script will call modem_service.sh as part of
# the hotplug event for the wwanX interface, and at that point we need to
# let the modem_service.sh script know which serial interface is the
# "control" interface for this mode, so we just set the mgmt device parameter
# here and call it a day, rest all gets done from 30-usb_ip
handle_sierranet() {
	local ttydevice
	local ifname

	ttydevice=$(gettty_device)
	if [ -z "$ttydevice" ]; then
		log "No TTY device: $usbpath"
		return
	fi

	count=1
	while [ $count -le 3 ];
	do
		imei=`gcom -d $ttydevice -s /etc/gcom/getimei.gcom | grep -E '[0-9]+'`
		if [ ! -z "$imei" ]; then
			break
		fi
		sleep 2
		count=$(($count+1))
	done

    if [ -z $imei ]; then
        log "Cannot load IMEI from $ttydevice, ignoring device."
        return
    fi

	# In sierranet modems we trigger the profile generation as soon as we get
    # the management TTY
	apn=$(at_get_apn $ttydevice $usbifname)
	PROFILE=/tmp/USB/${usbifname}.profile
	echo "APN=$apn" > ${PROFILE}

	lock $lockfile
	uci -c $modem_path add modems interface\\\ '"$usbifname"'
	uci -c $modem_path set modems.$usbifname=interface
	uci -c $modem_path set modems.$usbifname.device=''"$ttydevice"''
	uci -c $modem_path commit modems
	lock -u $lockfile

	log "DEVICE=$DEVICENAME: USBIF=$usbifname TTY=$ttydevice imei=$imei TYPE=sierranet"

	# If we have the WWAN net iface name already defined, we're ready to go;
	# otherwise we'll need to wait and it will get launched when the net iface
	# is processed.
	ifname=$(uci_get_modem_ifname $usbifname)
	if [ -z "$ifname" ]; then
		log "WWAN net not yet defined in sierranet modem: deferred"
		return
	fi

	log "WWAN modem setup: Sierra Direct IP"
	$modem_script_path/modem_service.sh $usbifname start
}

add_to_config() {

	# Action for the each USB
	local ttydevice
	local modemtype
	local product
	local ret

	if [ -z "$usbifname" ]
	then
		# log "Not a modem:devpath=$DEVPATH"
		return
	fi
	log "Hotplug add event: serial"
	product=$(cat $usbpath/../uevent | awk -F= '/PRODUCT/ { print $2}')
	if [ -z "$product" ]; then
		log "Ignoring tty device, no product: DEVICENAME:$DEVICENAME"
		return
	fi
	product="${product%/*}"
	# Normalize the USB ID so that it's ####:#### (4 chars each)
	product=$(printf "%04x:%04x" "0x${product%/*}" "0x${product#*/}")

	modemtype=$(get_modem_type "$DEVICENAME" "$product")
	#log "product = $product, modem type = $modemtype"
	if [ "$modemtype" == "ignore" ]; then
		log "Ignoring tty device: DEVICENAME:$DEVICENAME"
		return
	elif [ "$modemtype" == "qmihybrid" ]; then
		handle_qmi_hybrid
		return
	elif [ "$modemtype" == "sierranet" ]; then
		handle_sierranet
		return
	elif [ "$modemtype" == "None" ]; then
		log "Hybrid modem selected for $modemtype: DEVICENAME:$DEVICENAME"
		return
	fi

	ttydevice=$(gettty_device)
	if [ -z "$ttydevice" ]; then
		log "No TTY device: $usbpath"
		return
	fi

	log "DEVICE=$DEVICENAME: TYPE=$modemtype"

	lock $lockfile
	ret=$(check_device_config $usbifname)
	if [ "$ret" == "True" ]; then
		# Already dialup tty detected
		log "Dial device already detected"
		update_mgmt_device $ttydevice
		lock -u $lockfile
		return
	else
		update_dial_device "$ttydevice" "$product"
	fi

	log "Starting pppd script for $ttydevice"
	start_pppd_script
	lock -u $lockfile
}

remove_from_config() {
	local modemtype
	local ucigetmodem
	local product=$(uci_get_modem_product $usbifname)
	ucigetmodem=$(uci_get_modem_type $usbifname)
	modemtype=$(get_modem_type "$DEVICENAME" "$product")

	log "Hotplug remove event: $DEVICENAME: $product: $ucigetmodem"
	if [ ! -z $ucigetmodem ] && [ "$modemtype" == "$ucigetmodem" ];then
		# QMI hybrid modems will also get a wwan net interface
		# hotplug event as part of which these same sequence of steps
		# will happen
		if [ "$modemtype" == "qmihybrid" ]; then
			return;
		fi
		local pidfile="/$tmpdir/$usbifname.pid"
		$modem_script_path/modem_service.sh $usbifname stop
		uci -c $modem_path delete modems.$usbifname
		uci -c $modem_path commit modems
		log "Removed modems config"

		rm -rf $pidfile
		rm -rf /$tmpdir/$usbifname"_periodic.txt"
	fi

}

# Main starts here

# Variables for Unit Test
#DEVPATH="/devices/pci0000:00/0000:00:17.0/0000:01:00.0/0000:02:08.3/usb2/2-2/2-2:1.0/"
#DEVICENAME="2-2:1.0"
#ACTION=remove

#Nexcom
#DEVPATH=/devices/pci0000:00/0000:00:16.0/usb1/1-1/1-1.2/1-1.2:1.0/ttyUSB0
#DEVICENAME=ttyUSB0
#ACTION=add

. /opt/vc/modems/usb_common # has the USB numbering
local usbpath="/sys/$DEVPATH/"
local dialdevice=""
local mgmtdevice=""
local usbifname=$(usb_wan_naming $usbpath) # Will get the bus and port number
local lockfile="$tmpdir/$usbifname.lck"

set_eventdir "$usbifname: usb: $DEVICENAME"

debug_hotplugevents

case "$DEVICENAME" in
    console|ttyS[0-9]*)
	# do NOT write to console or "real" serial terminals
	;;
    *)
	if [ "$ACTION" = add ]; then
		add_to_config
	elif [ "$ACTION" = remove ]; then
		remove_from_config
	fi
	;;
esac
