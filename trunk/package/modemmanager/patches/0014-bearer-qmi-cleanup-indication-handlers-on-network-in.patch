From 2ed970614885d50316f3092289583d5ace985ea1 Mon Sep 17 00:00:00 2001
From: Aleksander Morgado <aleksander@aleksander.es>
Date: Fri, 15 Sep 2017 11:07:58 -0700
Subject: [PATCH] bearer-qmi: cleanup indication handlers on network-initiated
 disconnects

Otherwise, they'll end up queueing up and each time we get a new
indication the signal will get called multiple times:

    [/dev/cdc-wdm0] received message...
    <<<<<< RAW:
    <<<<<<   length = 20
    <<<<<<   data   = 01:13:00:80:01:09:04:00:00:01:00:07:00:20:04:00:05:00:00:00
    [/dev/cdc-wdm0] received generic indication (translated)...
    <<<<<< QMUX:
    <<<<<<   length  = 19
    <<<<<<   flags   = 0x80
    <<<<<<   service = "wds"
    <<<<<<   client  = 9
    <<<<<< QMI:
    <<<<<<   flags       = "indication"
    <<<<<<   transaction = 0
    <<<<<<   tlv_length  = 7
    <<<<<<   message     = "Event Report" (0x0001)
    <<<<<< TLV:
    <<<<<<   type       = "Preferred Data System" (0x20)
    <<<<<<   length     = 4
    <<<<<<   value      = 05:00:00:00
    <<<<<<   translated = lte
    <debug> [1504578559.592891] Got QMI WDS event report
    <debug> [1504578559.598212] Got QMI WDS event report
    <debug> [1504578559.601694] Got QMI WDS event report
---
 src/mm-bearer-qmi.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/src/mm-bearer-qmi.c b/src/mm-bearer-qmi.c
index c687db60..a9f7519c 100644
--- a/src/mm-bearer-qmi.c
+++ b/src/mm-bearer-qmi.c
@@ -1584,11 +1584,33 @@ reset_bearer_connection (MMBearerQmi *self,
                          gboolean reset_ipv6)
 {
     if (reset_ipv4) {
+        if (self->priv->client_ipv4) {
+            if (self->priv->packet_service_status_ipv4_indication_id)
+                common_setup_cleanup_packet_service_status_unsolicited_events (self,
+                                                                               self->priv->client_ipv4,
+                                                                               FALSE,
+                                                                               &self->priv->packet_service_status_ipv4_indication_id);
+            if (self->priv->event_report_ipv4_indication_id)
+                cleanup_event_report_unsolicited_events (self,
+                                                         self->priv->client_ipv4,
+                                                         &self->priv->event_report_ipv4_indication_id);
+        }
         self->priv->packet_data_handle_ipv4 = 0;
         g_clear_object (&self->priv->client_ipv4);
     }
 
     if (reset_ipv6) {
+        if (self->priv->client_ipv6) {
+            if (self->priv->packet_service_status_ipv6_indication_id)
+                common_setup_cleanup_packet_service_status_unsolicited_events (self,
+                                                                               self->priv->client_ipv6,
+                                                                               FALSE,
+                                                                               &self->priv->packet_service_status_ipv6_indication_id);
+            if (self->priv->event_report_ipv6_indication_id)
+                cleanup_event_report_unsolicited_events (self,
+                                                         self->priv->client_ipv6,
+                                                         &self->priv->event_report_ipv6_indication_id);
+        }
         self->priv->packet_data_handle_ipv6 = 0;
         g_clear_object (&self->priv->client_ipv6);
     }
-- 
2.14.1

