#!/bin/sh

# Copytight (C) 2013 Velocloud Inc

get_wda_version()
{
	qmicli -d "$1" --get-service-version-info | sed -ne "s/\s*wda (\([^']*\))/\1/p"
}

get_wda_data_format()
{
	qmicli -d "$1" --wda-get-data-format | sed -ne "s/\s*Link layer protocol: '\([^']*\)'/\1/p"
}

set_wda_data_format()
{
	qmicli -d "$1" --wda-set-data-format="802-3" | sed -ne "s/\s*Link layer protocol: '\([^']*\)'/\1/p"
}

set_ctl_data_format()
{
	# Note: There's no explicit error if this action fails. It usually just works.
	qmicli -d "$1" --device-open-net="net-802-3|net-no-qos-header" --dms-noop 1>/dev/null
}

set_ctl_sync()
{
	# Note: There's no explicit error if this action fails. It usually just works.
	qmicli -d "$1" --device-open-sync --dms-noop 1>/dev/null
}

qmi_get_apn()
{
	local device=$1
	local apn=''
	local mcode=''
	local mcc=''
	local mnc=''
	local apnfile='/tmp/'$device'.apn'
	/usr/bin/qmicli -d /dev/$device --nas-get-home-network > $apnfile
	mcc=`awk '/MCC/ {gsub("\x27","",$2); print $2}' $apnfile`
	if [ $? -eq 0 -a ! -z "$mcc" ]; then
		mnc=`awk '/MNC/ {gsub("\x27","",$2); print $2}' $apnfile`
		if [ $? -eq 0 -a ! -z "$mnc" ]; then
			while [ ${#mnc} -lt 3 ]; do
				mnc="0"$mnc
			done
			mcode=$mcc$mnc
		fi
	fi
	if [ ! -z $mcode ]; then
		apn=$(uci -c /etc/config/modems get mcodemap.${mcode}.apn)
	fi
	if [ -z $apn ]; then
		apn="broadband"
	fi
	echo $apn
}

# All QMI modems need to use the 802.3 link data format (i.e. packets with
# ethernet headers) instead of raw-ip (i.e. packets without ethernet headers).
# 802.3 is the format expected by the qmi_wwan kernel driver in the upstream
# Linux kernel, it cannot be changed programmatically.
#
# If the modem supports the WDA service, we'll use that one. Otherwise we'll
# run a DMS NOOP operation asking for 802.3 in the CTL service (the old way,
# always supported by modems without WDA).
ensure_802_3_data_format()
{
	local device=$1

	wda_version=`get_wda_version $device`
	if [ ! -z "$wda_version" ]; then
		cur_mode=`get_wwan_mode $device`
		if [ "$cur_mode" != "raw-ip" ]; then
			# Either OK, or in a bad state; either way, give up
			return
		fi

		# mode is raw-ip, and the device is reachable. Try setting to 802-3.
		echo "Trying to set QMI link layer protocol to 802-3" > /dev/kmsg
		num_attempts=0
		max_attempts=18
		sleep_interval=10
		cur_mode=`set_wda_data_format $device`
		while [ "$cur_mode" = "raw-ip" ]; do
			# sometimes retries help. Try upto 4 retries at 15 seconds each
			num_attempts=$((num_attempts+1))
			if [ $num_attempts -gt $max_attempts ]; then
				echo "Giving up on trying to set QMI link layer protocol to 802-3" > /dev/kmsg
				return
			fi
			echo "Re-trying to set QMI link layer protocol to 802-3, attempt $num_attempts (out of $max_attempts)" > /dev/kmsg
			sleep $sleep_interval
			cur_mode=`set_wda_data_format $device`
		done
	else
		echo "Trying to set QMI link layer protocol to 802.3... (CTL)" > /dev/kmsg
		set_ctl_data_format $device
	fi
}

# AC340U seems to have some bug when it starts locking into 2G mode, where the
# firmware locks up. See ticket #5355 .. We dont want this modem working in 2G
# mode, so disable 2G. Now this disabling doesnt seem to work unless we reload
# the qmi diver for the device, so doing a unbind bind to reload the driver. We
# are doing this only for 340U in specific because we dont know if other models
# have the problem and if this fix works for them if so. We are not even 100%
# sure if this fixes AC340U itself in all situations - this is all based on
# hear-say in modem/qmi aliases.
disable_AC340U_2G() {
    local device=$1
    local vendor=$(cat $usbpath/../../../idVendor)
    local product=$(cat $usbpath/../../../idProduct)
    local usbnum=`echo $usbpath | awk 'BEGIN { FS = "/" } ;{ print $(NF-2); }'`

    if [ "$vendor" = "1199" ] && [ "$product" = "9051" ]; then
	is_gsm=`/usr/bin/qmicli -d $device --nas-get-system-selection-preference | grep "Mode preference" | grep gsm`
	if [ -z "$is_gsm" ]; then
	    return;
	fi
	/usr/bin/qmicli -d $device --nas-set-system-selection-preference='umts|lte'
	echo "$usbnum" > /sys/bus/usb/drivers/qmi_wwan/unbind
	sleep 2
	echo "$usbnum" > /sys/bus/usb/drivers/qmi_wwan/bind
	sleep 2
    fi
}

at_get_imsi() {
	local dialdevice=$1
	local imsi_tries=3
	local tempfile='/tmp/'$dialdevice'.siminfo'
	local imsicmd="gcom -d /dev/$dialdevice -s /etc/gcom/vcgetimsi.gcom"
	local imsi_number
	while [ -z $imsi_number ] && [ "$imsi_tries" -ne 0 ]; do
		$imsicmd | awk 'NR>1 && $1 !~ /^OK$/ && $1 !~ /^$/ { print }' > $tempfile
		imsi_number=$(cat $tempfile | awk '{for(i=1;i<=NF;i++){ if(match($i, /[0-9]{14,15}$/)){print $i;break} } }')
		imsi_tries=$(expr $imsi_tries - 1)
	done
	rm -f $tempfile
	echo $imsi_number
}

at_get_apn() {
	local dialdevice=$1
	local imsi=`at_get_imsi $dialdevice`
	local mccmnc

	# Look for a match with a 2-digit MNC (i.e. no PCS digit)
	mccmnc="${imsi:0:5}"
	if [ ! -z $mccmnc ]; then
		apn=$(uci -c /etc/config/modems get mcodemap.${mccmnc}.apn 2>/dev/null)
	fi

	# Look for a match with a 3-digit MNC (i.e. with PCS digit)
	if [ -z $apn ]; then
		mccmnc="${imsi:0:6}"
		apn=$(uci -c /etc/config/modems get mcodemap.${mccmnc}.apn 2>/dev/null)
	fi

	# Assume we got a 2 digit MNC from IMSI, so build a 3-digit MNC and recheck
	if [ -z $apn ]; then
		mccmnc="${imsi:0:3}0${imsi:3:2}"
		apn=$(uci -c /etc/config/modems get mcodemap.${mccmnc}.apn 2>/dev/null)
	fi

	# Note: if APN not found, use empty APN
	echo $apn
}

set_usb_ip_over_ethernet() {
	local etherdevice=$DEVICENAME
	local modemtype=$1

	uci -c /etc/config add network interface\\\ '"$usbifname"'
	uci -c /etc/config set network.$usbifname=interface
	uci -c /etc/config set network.$usbifname.ifname=''"$etherdevice"''
	uci -c /etc/config set network.$usbifname.proto='dhcp'
	uci -c /etc/config set network.$usbifname.hostname=''"vc-$usbifname"''
	uci -c /etc/config commit network
	log "Updated network config"

	manufacturer=$(cat /sys$DEVPATH/../../../manufacturer)
	uci -c $modem_path add modems interface\\\ '"$usbifname"'
	uci -c $modem_path set modems.$usbifname=interface
	uci -c $modem_path set modems.$usbifname.ifname=''"$etherdevice"''
	uci -c $modem_path set modems.$usbifname.manufacturer=''"$manufacturer"''
	uci -c $modem_path set modems.$usbifname.type=''"$modemtype"''
	uci -c $modem_path set modems.$usbifname.product=''"$product"''

	if [ $modemtype == "huawei-ncm" ]; then
		local device=$(ls $usbpath/../../usbmisc)
		uci -c $modem_path set modems.$usbifname.device=''"/dev/$device"''

		#APN detection
		apn=$(at_get_apn $device)
		PROFILE=/tmp/USB/${usbifname}_huawei.profile
		echo "APN=$apn" > ${PROFILE}

		# Don't restart here
		log "Updated $device - $modemtype"
		return
	fi

	if [ $modemtype == "qmiwwan" ]; then
		local device=$(ls $usbpath/../../usbmisc)
		uci -c $modem_path set modems.$usbifname.device=''"/dev/$device"''

		# Start with a sync, so that we reset the endpoint
		set_ctl_sync /dev/$device

		# Ensure that 802.3 is used in the QMI modems, as that is what qmi_wwan expects
		ensure_802_3_data_format /dev/$device

		# Disable 2G mode for AC340U
		disable_AC340U_2G /dev/$device

		# qmi-network profile generation
		apn=$(qmi_get_apn $device)
		PROFILE=/tmp/USB/${usbifname}_qminetwork.profile
		rm -f ${PROFILE} >/dev/null 2>&1
		echo "APN=$apn"  >> ${PROFILE}
		echo "PROXY=yes" >> ${PROFILE}

		# For QMI modems, we just create the profile at this point.
		# The modem_service.sh script will launch the connection.
		return
	fi

	ubus call network reload
	status="CONNECTED SUCCESSFULLY"
	uci -c $modem_path set modems.$usbifname.status=''"$status"''
	uci -c $modem_path commit modems
	log "Updated modems config with ubus status=$status ubus_return=$?"

}

add_to_config() {

	# Action for the each USB
	local modemtype
	local product

	if [ -z "$usbifname" ]
	then
		# log "Not a modem:devpath=$DEVPATH"
		return
	fi

	log "Hotplug add event: IP"

	product=$(cat $usbpath/../../uevent | awk -F= '/PRODUCT/ { print $2}' | tr '/' ':')
	product=${product%:*}

	modemtype=$(get_modem_type "$DEVICENAME" "$product")

	if [ "$modemtype" == "None" ]; then
		log "Hybrid modem selected for $modemtype: $INTERFACE DEVICENAME:$DEVICENAME"
		return
	fi

	# Already detected and updated network
	log "DEVICE=$DEVICENAME: TYPE=$modemtype INTERFACE:$INTERFACE"

	ret=$(check_device_config $usbifname)
	if [ "$ret" == "True" ]; then
		# Already dialup tty detected
		log "net device $modemtype already detected"
		return
	fi

	log "Starting eth script for $ethdevice"
	set_usb_ip_over_ethernet "$modemtype" "$product"
	$modem_script_path/modem_service.sh $usbifname start
}

remove_from_config() {

	local modemtype
	local ucigetmodem
	local product=$(uci_get_modem_product $usbifname)
	ucigetmodem=$(uci_get_modem_type $usbifname)
	modemtype=$(get_modem_type "$DEVICENAME" "$product")

	log "Hotplug remove event: $DEVICENAME: $product: $ucigetmodem"
	if [ ! -z $ucigetmodem ] && [ "$modemtype" == "$ucigetmodem" ];then
		local pidfile="$tmpdir/$usbifname.pid"
		$modem_script_path/modem_service.sh $usbifname stop
		uci -c $network_config delete network.$usbifname
		uci -c $network_config commit network
		log "Removed network config"
		uci -c $modem_path delete modems.$usbifname
		uci -c $modem_path commit modems
		log "Removed modems config"

		ubus call network reload
		log "Reload network triggered"

		rm -rf $pidfile
		rm -rf $tmpdir/$usbifname"_periodic.txt"
	fi

}

# Main starts here

# Environmental Variables
#USER=root ACTION=remove OLDPWD=/etc HOME=/root SEQNUM=3702 HOTPLUG_TYPE=net IFINDEX=21 PS1=velocloud \u:\w\$ DEVPATH=/devices/pci0000:00/0000:00:17.0/0000:01:00.0/0000:02:02.3/usb1/1-2/1-2:1.0/net/eth4 LOGNAME=root DEVICENAME=eth4 TERM=vt102 SUBSYSTEM=net PATH=/bin:/sbin:/usr/bin:/usr/sbin SHELL=/bin/sh INTERFACE=eth4 PWD=/etc/Exp

# Variables for Unit Test
#DEVPATH="/devices/pci0000:00/0000:00:16.0/usb1/1-1/1-1.2/1-1.2:1.8/net/wwan0"
#DEVICENAME="wwan0"
#INTERFACE="wwan0"
#PRODUCT="1199/9051/345"
#ACTION=add

. /opt/vc/modems/usb_common

local usbpath="/sys$DEVPATH"
local usbifname=$(usb_wan_naming $usbpath) # The USB number fixed to the board

set_eventdir "$usbifname: net: $INTERFACE"

debug_hotplugevents

if [ "$ACTION" = add ]; then
	add_to_config
elif [ "$ACTION" = remove ]; then
	remove_from_config
fi

# Local Variables:
# sh-basic-offset: 8
# indent-tabs-mode: t
# End:
# vim: set ts=8 noexpandtab sw=8:
