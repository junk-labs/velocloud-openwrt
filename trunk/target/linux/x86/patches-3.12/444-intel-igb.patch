--- a/drivers/net/ethernet/intel/igb/Makefile
+++ b/drivers/net/ethernet/intel/igb/Makefile
@@ -34,4 +34,4 @@
 
 igb-objs := igb_main.o igb_ethtool.o e1000_82575.o \
 	    e1000_mac.o e1000_nvm.o e1000_phy.o e1000_mbx.o \
-	    e1000_i210.o igb_ptp.o igb_hwmon.o
+	    e1000_i210.o igb_ptp.o igb_hwmon.o igb_vc.o
--- a/drivers/net/ethernet/intel/igb/e1000_82575.c
+++ b/drivers/net/ethernet/intel/igb/e1000_82575.c
@@ -49,23 +49,23 @@
 static s32  igb_init_hw_82575(struct e1000_hw *);
 static s32  igb_phy_hw_reset_sgmii_82575(struct e1000_hw *);
 static s32  igb_read_phy_reg_sgmii_82575(struct e1000_hw *, u32, u16 *);
-static s32  igb_read_phy_reg_82580(struct e1000_hw *, u32, u16 *);
-static s32  igb_write_phy_reg_82580(struct e1000_hw *, u32, u16);
+s32  igb_read_phy_reg_82580(struct e1000_hw *, u32, u16 *);
+s32  igb_write_phy_reg_82580(struct e1000_hw *, u32, u16);
 static s32  igb_reset_hw_82575(struct e1000_hw *);
 static s32  igb_reset_hw_82580(struct e1000_hw *);
 static s32  igb_set_d0_lplu_state_82575(struct e1000_hw *, bool);
 static s32  igb_set_d0_lplu_state_82580(struct e1000_hw *, bool);
 static s32  igb_set_d3_lplu_state_82580(struct e1000_hw *, bool);
 static s32  igb_setup_copper_link_82575(struct e1000_hw *);
-static s32  igb_setup_serdes_link_82575(struct e1000_hw *);
+s32  igb_setup_serdes_link_82575(struct e1000_hw *);
 static s32  igb_write_phy_reg_sgmii_82575(struct e1000_hw *, u32, u16);
 static void igb_clear_hw_cntrs_82575(struct e1000_hw *);
 static s32  igb_acquire_swfw_sync_82575(struct e1000_hw *, u16);
-static s32  igb_get_pcs_speed_and_duplex_82575(struct e1000_hw *, u16 *,
+s32  igb_get_pcs_speed_and_duplex_82575(struct e1000_hw *, u16 *,
 						 u16 *);
 static s32  igb_get_phy_id_82575(struct e1000_hw *);
 static void igb_release_swfw_sync_82575(struct e1000_hw *, u16);
-static bool igb_sgmii_active_82575(struct e1000_hw *);
+bool igb_sgmii_active_82575(struct e1000_hw *);
 static s32  igb_reset_init_script_82575(struct e1000_hw *);
 static s32  igb_read_mac_addr_82575(struct e1000_hw *);
 static s32  igb_set_pcie_completion_timeout(struct e1000_hw *hw);
@@ -87,7 +87,7 @@
  *  Called to determine if the I2C pins are being used for I2C or as an
  *  external MDIO interface since the two options are mutually exclusive.
  **/
-static bool igb_sgmii_uses_mdio_82575(struct e1000_hw *hw)
+bool igb_sgmii_uses_mdio_82575(struct e1000_hw *hw)
 {
 	u32 reg = 0;
 	bool ext_mdio = false;
@@ -255,6 +255,11 @@
 	nvm->delay_usec = 1;
 
 	switch (nvm->override) {
+	case e1000_nvm_override_spi_vc:
+		nvm->page_size = 32;
+		nvm->address_bits = 16;
+		nvm->word_size = 256*1024/16;
+		break;
 	case e1000_nvm_override_spi_large:
 		nvm->page_size = 32;
 		nvm->address_bits = 16;
@@ -440,6 +445,7 @@
 static s32 igb_get_invariants_82575(struct e1000_hw *hw)
 {
 	struct e1000_mac_info *mac = &hw->mac;
+	struct e1000_nvm_info *nvm = &hw->nvm;
 	struct e1000_dev_spec_82575 * dev_spec = &hw->dev_spec._82575;
 	s32 ret_val;
 	u32 ctrl_ext = 0;
@@ -461,6 +467,10 @@
 	case E1000_DEV_ID_82576_SERDES_QUAD:
 		mac->type = e1000_82576;
 		break;
+	case E1000_DEV_ID_82580_VC:
+		nvm->override = e1000_nvm_override_spi_vc;
+		mac->type = e1000_82580;
+		break;
 	case E1000_DEV_ID_82580_COPPER:
 	case E1000_DEV_ID_82580_FIBER:
 	case E1000_DEV_ID_82580_QUAD_FIBER:
@@ -592,6 +602,14 @@
 		break;
 	}
 
+	// init velocloud phy params;
+
+	{ extern s32 igb_vc_probe(struct e1000_hw *);
+	ret_val = igb_vc_probe(hw);
+	if( !ret_val)
+		goto out;
+	}
+
 	/* setup PHY parameters */
 	ret_val = igb_init_phy_params_82575(hw);
 
@@ -1242,7 +1260,7 @@
  *  Using the physical coding sub-layer (PCS), retrieve the current speed and
  *  duplex, then store the values in the pointers provided.
  **/
-static s32 igb_get_pcs_speed_and_duplex_82575(struct e1000_hw *hw, u16 *speed,
+s32 igb_get_pcs_speed_and_duplex_82575(struct e1000_hw *hw, u16 *speed,
 						u16 *duplex)
 {
 	struct e1000_mac_info *mac = &hw->mac;
@@ -1532,7 +1550,7 @@
  *  interface (sgmii), or serdes fiber is being used.  Configures the link
  *  for auto-negotiation or forces speed/duplex.
  **/
-static s32 igb_setup_serdes_link_82575(struct e1000_hw *hw)
+s32 igb_setup_serdes_link_82575(struct e1000_hw *hw)
 {
 	u32 ctrl_ext, ctrl_reg, reg, anadv_reg;
 	bool pcs_autoneg;
@@ -1672,7 +1690,7 @@
  *  which can be enabled for use in the embedded applications.  Simply
  *  return the current state of the sgmii interface.
  **/
-static bool igb_sgmii_active_82575(struct e1000_hw *hw)
+bool igb_sgmii_active_82575(struct e1000_hw *hw)
 {
 	struct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;
 	return dev_spec->sgmii_active;
@@ -2038,7 +2056,7 @@
  *  Reads the MDI control register in the PHY at offset and stores the
  *  information read to data.
  **/
-static s32 igb_read_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 *data)
+s32 igb_read_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 *data)
 {
 	s32 ret_val;
 
@@ -2062,7 +2080,7 @@
  *
  *  Writes data to MDI control register in the PHY at offset.
  **/
-static s32 igb_write_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 data)
+s32 igb_write_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 data)
 {
 	s32 ret_val;
 
--- a/drivers/net/ethernet/intel/igb/e1000_defines.h
+++ b/drivers/net/ethernet/intel/igb/e1000_defines.h
@@ -742,9 +742,12 @@
 #define NVM_A8_OPCODE_SPI          0x08 /* opcode bit-3 = address bit-8 */
 #define NVM_WREN_OPCODE_SPI        0x06 /* NVM set Write Enable latch */
 #define NVM_RDSR_OPCODE_SPI        0x05 /* NVM read Status register */
+#define NVM_WRSR_OPCODE_SPI        0x01 /* NVM write Status register */
 
 /* SPI NVM Status Register */
 #define NVM_STATUS_RDY_SPI         0x01
+#define NVM_STATUS_WEN_SPI         0x02
+#define NVM_STATUS_WPEN_SPI        0x80
 
 /* Word definitions for ID LED Settings */
 #define ID_LED_RESERVED_0000 0x0000
@@ -794,6 +797,7 @@
 #define M88E1000_PHY_SPEC_STATUS   0x11  /* PHY Specific Status Register */
 #define M88E1000_EXT_PHY_SPEC_CTRL 0x14  /* Extended PHY Specific Control */
 
+#define M88E1000_PHY_PAGE22        0x16	/* Reg 22 for page setting of regs 0..21,23..28 */
 #define M88E1000_PHY_PAGE_SELECT   0x1D  /* Reg 29 for page number setting */
 #define M88E1000_PHY_GEN_CONTROL   0x1E  /* Its meaning depends on reg 29 */
 
--- a/drivers/net/ethernet/intel/igb/e1000_hw.h
+++ b/drivers/net/ethernet/intel/igb/e1000_hw.h
@@ -49,6 +49,7 @@
 #define E1000_DEV_ID_82575EB_COPPER		0x10A7
 #define E1000_DEV_ID_82575EB_FIBER_SERDES	0x10A9
 #define E1000_DEV_ID_82575GB_QUAD_COPPER	0x10D6
+#define E1000_DEV_ID_82580_VC			0x1509
 #define E1000_DEV_ID_82580_COPPER		0x150E
 #define E1000_DEV_ID_82580_FIBER		0x150F
 #define E1000_DEV_ID_82580_SERDES		0x1510
@@ -104,6 +105,8 @@
 	e1000_media_type_copper = 1,
 	e1000_media_type_fiber = 2,
 	e1000_media_type_internal_serdes = 3,
+	e1000_media_type_switch = 4,
+	e1000_media_type_sfp = 5,
 	e1000_num_media_types
 };
 
@@ -120,6 +123,7 @@
 	e1000_nvm_override_none = 0,
 	e1000_nvm_override_spi_small,
 	e1000_nvm_override_spi_large,
+	e1000_nvm_override_spi_vc,
 };
 
 enum e1000_phy_type {
@@ -133,6 +137,7 @@
 	e1000_phy_ife,
 	e1000_phy_82580,
 	e1000_phy_i210,
+	e1000_phy_m88sw,
 };
 
 enum e1000_bus_type {
@@ -427,6 +432,13 @@
 	struct e1000_thermal_sensor_data thermal_sensor_data;
 };
 
+enum e1000_phy_port {
+	e1000_port_cpu = 0,
+	e1000_port_sgmii,
+	e1000_port_phy,
+	e1000_n_phy_ports,
+};
+
 struct e1000_phy_info {
 	struct e1000_phy_operations ops;
 
@@ -453,6 +465,7 @@
 	u16 min_cable_length;
 
 	u8 mdix;
+	u8 ports[e1000_n_phy_ports];
 
 	bool disable_polarity_correction;
 	bool is_mdix;
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -91,6 +91,7 @@
 	{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_FIBER), board_82575 },
 	{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SERDES), board_82575 },
 	{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SGMII), board_82575 },
+	{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_VC), board_82575 },
 	{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_COPPER), board_82575 },
 	{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_FIBER), board_82575 },
 	{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_QUAD_FIBER), board_82575 },
@@ -184,6 +185,11 @@
 static int igb_vf_configure(struct igb_adapter *adapter, int vf);
 #endif
 
+extern int igb_vc_i2c_init(struct igb_adapter *);
+extern void igb_vc_i2c_exit(struct igb_adapter *);
+extern int igb_vc_dsa_init(struct igb_adapter *);
+extern void igb_vc_dsa_exit(struct igb_adapter *);
+
 #ifdef CONFIG_PM
 #ifdef CONFIG_PM_SLEEP
 static int igb_suspend(struct device *);
@@ -252,6 +258,10 @@
 MODULE_LICENSE("GPL");
 MODULE_VERSION(DRV_VERSION);
 
+static int bad_eeprom = 0;
+module_param(bad_eeprom, int, 0);
+MODULE_PARM_DESC(bad_eeprom, "Ignore all EEPROM errors to reflash it.");
+
 #define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)
 static int debug = -1;
 module_param(debug, int, 0);
@@ -1996,6 +2006,18 @@
 	return status;
 }
 
+// error out or ignore NVM checksum errors;
+
+static int
+igb_nvm_checksum_error(struct pci_dev *pdev)
+{
+	dev_err(&pdev->dev, "The NVM Checksum Is Not Valid\n");
+	if( !bad_eeprom)
+		return(-EIO);
+	dev_err(&pdev->dev, "Invalid NVM Checksum Ignored\n");
+	return(0);
+}
+
 /**
  *  igb_probe - Device Initialization Routine
  *  @pdev: PCI device information struct
@@ -2109,6 +2131,8 @@
 	memcpy(&hw->nvm.ops, ei->nvm_ops, sizeof(hw->nvm.ops));
 	/* Initialize skew-specific constants */
 	err = ei->get_invariants(hw);
+	if(bad_eeprom)
+		err = 0;
 	if (err)
 		goto err_sw_init;
 
@@ -2188,18 +2212,17 @@
 	case e1000_i211:
 		if (igb_get_flash_presence_i210(hw)) {
 			if (hw->nvm.ops.validate(hw) < 0) {
-				dev_err(&pdev->dev,
-					"The NVM Checksum Is Not Valid\n");
-				err = -EIO;
-				goto err_eeprom;
+				err = igb_nvm_checksum_error(pdev);
+				if(err)
+					goto err_eeprom;
 			}
 		}
 		break;
 	default:
 		if (hw->nvm.ops.validate(hw) < 0) {
-			dev_err(&pdev->dev, "The NVM Checksum Is Not Valid\n");
-			err = -EIO;
-			goto err_eeprom;
+			err = igb_nvm_checksum_error(pdev);
+			if(err)
+				goto err_eeprom;
 		}
 		break;
 	}
@@ -2212,8 +2235,11 @@
 
 	if (!is_valid_ether_addr(netdev->dev_addr)) {
 		dev_err(&pdev->dev, "Invalid MAC Address\n");
-		err = -EIO;
-		goto err_eeprom;
+		if( !bad_eeprom) {
+			err = -EIO;
+			goto err_eeprom;
+		} else
+			dev_err(&pdev->dev, "Invalid MAC Address Ignored\n");
 	}
 
 	/* get firmware version for ethtool -i */
@@ -2309,6 +2335,10 @@
 		dev_err(&pdev->dev, "failed to init i2c interface\n");
 		goto err_eeprom;
 	}
+	// init vc i2c to sfp;
+	err = igb_vc_i2c_init(adapter);
+	if(err)
+		dev_err(&pdev->dev, "failed to init sfp i2c interface\n");
 
 	/* let the f/w know that the h/w is now under the control of the
 	 * driver. */
@@ -2319,6 +2349,11 @@
 	if (err)
 		goto err_register;
 
+	// init vc mdio for dsa switch;
+	err = igb_vc_dsa_init(adapter);
+	if(err)
+		dev_err(&pdev->dev, "failed to init dsa interface\n");
+
 	/* carrier off reporting is important to ethtool even BEFORE open */
 	netif_carrier_off(netdev);
 
@@ -2534,6 +2569,8 @@
 {
 	/* free the adapter bus structure */
 	i2c_del_adapter(&adapter->i2c_adap);
+	// free vc i2c to sfp;
+	igb_vc_i2c_exit(adapter);
 }
 
 /**
@@ -2575,6 +2612,8 @@
 		wr32(E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_MODE_DISABLE);
 	}
 #endif
+	// free vc dsa interface;
+	igb_vc_dsa_exit(adapter);
 
 	/* Release control of h/w to f/w.  If f/w is AMT enabled, this
 	 * would have already happened in close and is redundant.
@@ -2721,7 +2760,7 @@
 	adapter->tx_work_limit = IGB_DEFAULT_TX_WORK;
 
 	adapter->max_frame_size = netdev->mtu + ETH_HLEN + ETH_FCS_LEN +
-				  VLAN_HLEN;
+				  VLAN_HLEN + ETH_EDSA_LEN;
 	adapter->min_frame_size = ETH_ZLEN + ETH_FCS_LEN;
 
 	spin_lock_init(&adapter->stats64_lock);
@@ -3879,6 +3918,8 @@
 	case e1000_media_type_copper:
 		if (!hw->mac.get_link_status)
 			return true;
+	case e1000_media_type_switch:
+	case e1000_media_type_sfp:
 	case e1000_media_type_internal_serdes:
 		hw->mac.ops.check_for_link(hw);
 		link_active = !hw->mac.get_link_status;
@@ -4844,7 +4885,7 @@
 {
 	struct igb_adapter *adapter = netdev_priv(netdev);
 	struct pci_dev *pdev = adapter->pdev;
-	int max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;
+	int max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN + ETH_EDSA_LEN;
 
 	if ((new_mtu < 68) || (max_frame > MAX_JUMBO_FRAME_SIZE)) {
 		dev_err(&pdev->dev, "Invalid MTU setting\n");
@@ -6466,6 +6507,7 @@
 		unsigned char *network;
 		/* l2 headers */
 		struct ethhdr *eth;
+		__be16 edsa[4];
 		struct vlan_hdr *vlan;
 		/* l3 headers */
 		struct iphdr *ipv4;
@@ -6486,6 +6528,15 @@
 	protocol = hdr.eth->h_proto;
 	hdr.network += ETH_HLEN;
 
+	// handle any EDSA tag if present;
+	if(protocol == __constant_htons(ETH_P_EDSA)) {
+		if ((hdr.network - data) > (max_len - ETH_EDSA_LEN))
+			return max_len;
+
+		protocol = hdr.edsa[3];
+		hdr.network += ETH_EDSA_LEN;
+	}
+
 	/* handle any vlan tag if present */
 	if (protocol == __constant_htons(ETH_P_8021Q)) {
 		if ((hdr.network - data) > (max_len - VLAN_HLEN))
--- /dev/null
+++ b/drivers/net/ethernet/intel/igb/igb_vc.c
@@ -0,0 +1,2857 @@
+/* Velocloud Intel IGB Ethernet driver
+ * Copyright(c) 2014 Velocloud Inc.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+*/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/if_ether.h>
+#include <linux/i2c.h>
+
+#include "e1000_mac.h"
+#include "e1000_82575.h"
+#include "e1000_hw.h"
+#include "igb.h"
+
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <net/dsa.h>
+
+#undef IGB_VC_DEBUG
+#ifdef IGB_VC_DEBUG
+#define vcdbg(fmt, ...) printk("%s/%d " fmt, __func__, hw->bus.func, ##__VA_ARGS__);
+#else
+#define vcdbg(fmt, ...)
+#endif
+
+// dump switch/phy regs;
+
+#undef IGB_VC_DUMP_6320
+#undef IGB_VC_DUMP_6176
+#undef IGB_VC_DUMP_1112
+#undef IGB_VC_DUMP_ATU
+
+#undef IGB_VC_DUMP_DSA_REG
+#ifdef IGB_VC_DUMP_DSA_REG
+#define vcdsareg(fmt, ...) printk("%s:" fmt, __func__, ##__VA_ARGS__);
+#else
+#define vcdsareg(fmt, ...)
+#endif
+
+#undef IGB_VC_DUMP_DSA_PHY
+#ifdef IGB_VC_DUMP_DSA_PHY
+#define vcdsaphy(fmt, ...) printk("%s:" fmt, __func__, ##__VA_ARGS__);
+#else
+#define vcdsaphy(fmt, ...)
+#endif
+
+// number of i354 rangeley bus functions;
+
+#define IGB_VC_N_BUS_FUNC 4
+
+// functions;
+
+extern bool igb_sgmii_active_82575(struct e1000_hw *hw);
+extern bool igb_sgmii_uses_mdio_82575(struct e1000_hw *hw);
+extern s32  igb_read_phy_reg_82580(struct e1000_hw *, u32, u16 *);
+extern s32  igb_write_phy_reg_82580(struct e1000_hw *, u32, u16);
+extern s32 igb_setup_serdes_link_82575(struct e1000_hw *hw);
+extern s32 igb_get_pcs_speed_and_duplex_82575(struct e1000_hw *, u16 *, u16 *);
+extern s32 igb_check_polarity_m88(struct e1000_hw *hw);
+extern s32 igb_get_cable_length_m88_gen2(struct e1000_hw *hw);
+
+s32 igb_vc_i2c_init(struct igb_adapter *adapter);
+void igb_vc_i2c_exit(struct igb_adapter *adapter);
+
+// MDIO timeout;
+
+#define IGB_VC_MDIO_TIMEOUT 100		// in 10us steps;
+#define IGB_VC_SMI_MDIO_RETRIES 50	// # of smi mdio retries;
+
+// marvell switch defs;
+
+#define M88E6320_ID ((M88_VENDOR << 16) | 0x1150)
+#define M88E6176_ID ((M88_VENDOR << 16) | 0x1760)
+#define M88E1112_ID ((M88_VENDOR << 16) | 0x0c90)
+
+#define M88_SW_PORT_BASE 0x10		// base of port registers;
+#define M88_SW_PORT_STATUS 0x00		// port status reg;
+#define M88_SW_PORT_PHYSCTRL 0x01	// port physical control reg;
+#define M88_SW_PORT_PROD_ID 0x03	// product ID reg;
+#define M88_SW_PORT_CONTROL 0x04	// port control reg;
+#define M88_SW_PORT_VLAN_MAP 0x06	// port based vlan map;
+
+#define M88_SW_PORT_STATUS_PHYDET	(1 << 12)
+#define M88_SW_PORT_STATUS_LINK_UP	(1 << 11)
+#define M88_SW_PORT_STATUS_DUPLEX	(1 << 10)
+#define M88_SW_PORT_STATUS_SPEED	(3 << 8)
+#define M88_SW_PORT_STATUS_SPEED_10	(0 << 8)
+#define M88_SW_PORT_STATUS_SPEED_100	(1 << 8)
+#define M88_SW_PORT_STATUS_SPEED_1000	(2 << 8)
+
+#define M88_SW_PORT_CONTROL_DIS		(0 << 0)
+#define M88_SW_PORT_CONTROL_BLKLIST	(1 << 0)
+#define M88_SW_PORT_CONTROL_LEARN	(2 << 0)
+#define M88_SW_PORT_CONTROL_FWD		(3 << 0)
+
+#define M88_SW_GLOBAL1 0x1b		// global1 regs;
+#define M88_SW_GLOBAL2 0x1c		// global2 regs;
+#define M88_SW_GLOBAL3 0x1d		// global3 regs;
+
+#define M88_SW_GL1_CTRL 4
+#define M88_SW_GL1_CTRL_SWRESET 0x8000
+
+#define M88_GL2_SMI_CMD 0x18		// SMI command;
+#define M88_GL2_SMI_CMD_BUSY 0x8000	// SMI busy;
+#define M88_GL2_SMI_CMD_MODE 0x1000	// SMI mode, 0=clause45, 1=clause22;
+#define M88_GL2_SMI_CMD_OP 0x0c00	// SMI op;
+#define M88_GL2_SMI_CMD_OP_WRITE 0x0400	// SMI write;
+#define M88_GL2_SMI_CMD_OP_READ 0x0800	// SMI read;
+#define M88_GL2_SMI_CMD_ADDR 0x003e	// SMI device address;
+#define M88_GL2_SMI_CMD_REG 0x001f	// SMI register address;
+#define M88_GL2_SMI_DATA 0x19		// SMI data;
+
+// per-port registers;
+
+#define M88_SW_REG(bank,reg) ((bank<<5) | reg)
+#define M88_SW_PORT_REG(port,reg) (((M88_SW_PORT_BASE+port)<<5) | reg)
+
+// phy fiber special control;
+
+#define M88E1000_SPEC_CTRL_SIGDET (1 << 9)
+
+// mac special control;
+
+#define M88E1000_SPEC_CTRL_PREFER			(3 << 10)
+#define M88E1000_SPEC_CTRL_PREFER_NONE			(0 << 10)
+#define M88E1000_SPEC_CTRL_PREFER_FIBER			(1 << 10)
+#define M88E1000_SPEC_CTRL_PREFER_COPPER		(2 << 10)
+
+#define M88E1000_SPEC_CTRL_MODE				(7 << 7)
+#define M88E1000_SPEC_CTRL_MODE_100BASEFX		(0 << 7)
+#define M88E1000_SPEC_CTRL_MODE_COPPER_GBIC		(1 << 7)
+#define M88E1000_SPEC_CTRL_MODE_A_COPPER_SGMII		(2 << 7)
+#define M88E1000_SPEC_CTRL_MODE_A_COPPER_1000BASEX	(3 << 7)
+#define M88E1000_SPEC_CTRL_MODE_COPPER_ONLY		(5 << 7)
+#define M88E1000_SPEC_CTRL_MODE_SGMII_ONLY		(6 << 7)
+#define M88E1000_SPEC_CTRL_MODE_1000BASEX_ONLY		(7 << 7)
+
+#define M88E1000_SPEC_CTRL_PWR_UP			(1 << 3)
+#define M88E1000_SPEC_CTRL_ENH_SGMII			(1 << 2)
+
+// others;
+
+#define IGB_VC_PAGE 0x8000	// set phy page;
+
+// SFP I2C;
+
+#define IGB_VC_SFP "sfp"	// sfp i2c driver name;
+#define IGB_VC_SFP_BUS_FUNC	3
+
+#define SFP_OFF_IDENTIFIER	0
+#define SFP_IDENTIFIER_SFP	0x03
+
+#define SFP_OFF_VENDOR		20
+#define SFP_SIZE_VENDOR		16
+
+#define SFP_OFF_OUI		37
+#define SFP_SIZE_OUI		3
+
+#define SFP_OFF_PARTNUM		40
+#define SFP_SIZE_PARTNUM	16
+
+enum sfp_i2c_client {
+	SFP_EEPROM = 0,
+	SFP_DMI,
+	N_SFP_CLIENT,
+};
+
+struct vc_i2c_sfp {
+	struct igb_adapter *adapter;
+	struct i2c_client *client[N_SFP_CLIENT];
+	int plugged;
+	char vendor[SFP_SIZE_VENDOR+1];
+	unsigned char oui[SFP_SIZE_OUI];
+	char partnum[SFP_SIZE_PARTNUM+1];
+};
+
+// sfp i2c data;
+
+static unsigned short igb_vc_i2c_addrs[] = { 0x50, 0x51, I2C_CLIENT_END };
+static struct vc_i2c_sfp igb_vc_i2c_sfp;
+
+// DSA specific;
+
+#define VC_NAME "vc"
+#define VC_DSA "dsa"
+
+#define IGB_VC_DSA_BUS_FUNC	1
+
+// switch tree;
+
+static struct dsa_chip_data vc_switch = {
+	.sw_addr = 0,
+	.port_names = {
+		"sw%d",         // 0
+		"sw%d",         // 1
+		"sw%d",         // 2
+		"sw%d",         // 3
+		"cpu",          // 4
+	},
+};
+
+static struct dsa_platform_data vc_switch_data = {
+	.nr_chips = 1,
+	.chip = &vc_switch,
+};
+
+struct vc_dsa_priv {
+	struct e1000_hw *hw;
+	struct platform_device pdev;
+	int irqs[PHY_MAX_ADDR];
+};
+
+
+// busy-wait for MDIO completion;
+// returns <0 if error, else mdic bits;
+// XXX why we not use completion intr?
+
+static s32
+igb_vc_mdio_wait(struct e1000_hw *hw)
+{
+	int i;
+	u32 mdic;
+
+	// poll the ready bit, busy-waiting;
+
+	for(i = 0; i < IGB_VC_MDIO_TIMEOUT; i++) {
+		udelay(10);
+		mdic = rd32(E1000_MDIC);
+		if(mdic & E1000_MDIC_READY)
+			break;
+	}
+	if( !(mdic & E1000_MDIC_READY)) {
+		hw_dbg("MDIO read did not complete\n");
+		return(-E1000_ERR_PHY);
+	}
+	if(mdic & E1000_MDIC_ERROR) {
+		hw_dbg("MDIO error\n");
+		return(-E1000_ERR_PHY);
+	}
+	return(mdic & 0xffff);
+}
+
+// set page for phy access;
+
+static s32
+igb_vc_mdio_page(struct e1000_hw *hw, u16 page)
+{
+	u32 mdic;
+
+	mdic = E1000_MDIC_OP_WRITE | (M88E1000_PHY_PAGE22 << E1000_MDIC_REG_SHIFT) | page;
+	wr32(E1000_MDIC, mdic);
+	return(igb_vc_mdio_wait(hw));
+}
+
+// read MDIO registers;
+// works with single/multi-chip addressing;
+
+static s32
+igb_vc_mdio_read(struct e1000_hw *hw, u32 reg, u16 *data)
+{
+	u32 addr, mdic;
+	s32 ret = 0;
+
+	// phy->addr=0 indicates single-chip addressing;
+
+	addr = hw->phy.addr;
+	if(addr == 0)
+		addr = (reg >> 5) & 0x1f;
+	//printk("%s %d/%d\n", __func__, addr, reg);
+
+	// acquire MDIO interface;
+
+	ret = hw->phy.ops.acquire(hw);
+	if(ret)
+		goto out;
+
+	// the phy address is now in MDICNFG;
+	// always overwrite PHY addr, since other device can share the bus;
+
+	mdic = rd32(E1000_MDICNFG);
+	mdic &= (E1000_MDICNFG_EXT_MDIO | E1000_MDICNFG_COM_MDIO);
+	mdic |= (addr << E1000_MDIC_PHY_SHIFT);
+	wr32(E1000_MDICNFG, mdic);
+
+	// set phy page;
+	// needs to be atomic with respect to mdio access;
+
+	if(reg & IGB_VC_PAGE) {
+		ret = igb_vc_mdio_page(hw, reg >> 16);
+		if(ret < 0)
+			goto fail;
+	}
+
+	// setup MDIC op code;
+	// this starts the MDIO access by the MAC;
+
+	reg &= 0x1f;
+	mdic = E1000_MDIC_OP_READ | (reg << E1000_MDIC_REG_SHIFT);
+	wr32(E1000_MDIC, mdic);
+
+	// wait for MDIC to complete or error;
+	// release MDIO interface;
+
+	ret = igb_vc_mdio_wait(hw);
+fail:
+        hw->phy.ops.release(hw);
+	if(ret < 0)
+		goto out;
+	*data = ret;
+	ret = 0;
+out:
+	return(ret);
+}
+
+// write MDIO registers;
+// works with single/multi-chip addressing;
+
+static s32
+igb_vc_mdio_write(struct e1000_hw *hw, u32 reg, u16 data)
+{
+	u32 addr, mdic;
+	s32 ret = 0;
+
+	// phy->addr=0 indicates single-chip addressing;
+
+	addr = hw->phy.addr;
+	if(addr == 0)
+		addr = (reg >> 5) & 0x1f;
+	//printk("%s %d/%d=0x%x\n", __func__, addr, reg, data);
+
+	// acquire MDIO interface;
+
+	ret = hw->phy.ops.acquire(hw);
+	if(ret)
+		goto out;
+
+	// the phy address is now in MDICNFG;
+	// always overwrite PHY addr, since other device can share the bus;
+
+	mdic = rd32(E1000_MDICNFG);
+	mdic &= (E1000_MDICNFG_EXT_MDIO | E1000_MDICNFG_COM_MDIO);
+	mdic |= (addr << E1000_MDIC_PHY_SHIFT);
+	wr32(E1000_MDICNFG, mdic);
+
+	// set phy page;
+	// needs to be atomic with respect to mdio access;
+
+	if(reg & IGB_VC_PAGE) {
+		ret = igb_vc_mdio_page(hw, reg >> 16);
+		if(ret < 0)
+			goto fail;
+	}
+
+	// setup MDIC op code;
+	// this starts the MDIO access by the MAC;
+
+	reg &= 0x1f;
+	mdic = E1000_MDIC_OP_WRITE | (reg << E1000_MDIC_REG_SHIFT) | data;
+	wr32(E1000_MDIC, mdic);
+
+	// wait for MDIC to complete or error;
+	// release MDIO interface;
+
+	ret = igb_vc_mdio_wait(hw);
+fail:
+        hw->phy.ops.release(hw);
+	if(ret < 0)
+		goto out;
+	ret = 0;
+out:
+	return(ret);
+}
+
+// read MDIO SGMII register;
+// on 88e1112 point to the MAC of the port;
+
+static s32
+igb_vc_m88phy_sgmii_mdio_read(struct e1000_hw *hw, u32 reg, u16 *data)
+{
+	s32 ret;
+
+	ret = igb_vc_mdio_read(hw, IGB_VC_PAGE | (2 << 16) | reg, data);
+	vcdbg("%d/%d = %d 0x%x\n", 2, reg, ret, *data);
+	return(ret);
+}
+
+// write MDIO SGMII register;
+// on 88e1112 point to the MAC of the port;
+
+static s32
+igb_vc_m88phy_sgmii_mdio_write(struct e1000_hw *hw, u32 reg, u16 data)
+{
+	s32 ret;
+
+	ret = igb_vc_mdio_write(hw, IGB_VC_PAGE | (2 << 16) | reg, data);
+	vcdbg("%d/%d = %d 0x%x\n", 2, reg, ret, data);
+	return(ret);
+}
+
+// read MDIO SFP PHY register;
+// on 88e1112 point to the SFP side;
+
+static s32
+igb_vc_m88phy_sfp_mdio_read(struct e1000_hw *hw, u32 reg, u16 *data)
+{
+	s32 ret;
+
+	ret = igb_vc_mdio_read(hw, IGB_VC_PAGE | (1 << 16) | reg, data);
+	vcdbg("%d/%d = %d 0x%x\n", 1, reg, ret, *data);
+	return(ret);
+}
+
+// write MDIO PHY register;
+// on 88e1112 point to the SFP side;
+
+static s32
+igb_vc_m88phy_sfp_mdio_write(struct e1000_hw *hw, u32 reg, u16 data)
+{
+	s32 ret;
+
+	ret = igb_vc_mdio_write(hw, IGB_VC_PAGE | (1 << 16) | reg, data);
+	vcdbg("%d/%d = %d 0x%x\n", 1, reg, ret, data);
+	return(ret);
+}
+
+// issue smi command;
+// wait for completion;
+// reg[4:0] register;
+// reg[9:5] device (copper 0..N, 0xf serdes);
+
+static s32
+igb_vc_smi_cmd(struct e1000_hw *hw, u32 reg, u16 write, u16 *data)
+{
+	u32 mdic, i;
+	u16 cmd;
+	s32 ret;
+
+	// write SMI_DATA for write command;
+
+	cmd = M88_GL2_SMI_CMD_BUSY | M88_GL2_SMI_CMD_MODE | (reg & 0x3ff);
+	if(write) {
+		mdic = E1000_MDIC_OP_WRITE | (M88_GL2_SMI_DATA << E1000_MDIC_REG_SHIFT) | *data;
+		wr32(E1000_MDIC, mdic);
+		ret = igb_vc_mdio_wait(hw);
+		if(ret < 0)
+			goto out;
+		cmd |= M88_GL2_SMI_CMD_OP_WRITE;
+	} else
+		cmd |= M88_GL2_SMI_CMD_OP_READ;
+
+	// issue smi command;
+
+	mdic = E1000_MDIC_OP_WRITE | (M88_GL2_SMI_CMD << E1000_MDIC_REG_SHIFT) | cmd;
+	wr32(E1000_MDIC, mdic);
+	ret = igb_vc_mdio_wait(hw);
+	if(ret < 0)
+		goto out;
+
+	// poll SMI_CMD for completion;
+
+	for(i = 0; i < IGB_VC_SMI_MDIO_RETRIES; i++) {
+		mdic = E1000_MDIC_OP_READ | (M88_GL2_SMI_CMD << E1000_MDIC_REG_SHIFT);
+		wr32(E1000_MDIC, mdic);
+		ret = igb_vc_mdio_wait(hw);
+		if(ret < 0)
+			goto out;
+		if( !(ret & M88_GL2_SMI_CMD_BUSY))
+			break;
+		udelay(10);
+	}
+	if(i >= IGB_VC_SMI_MDIO_RETRIES) {
+		ret = -E1000_ERR_PHY;
+		goto out;
+	}
+
+	// read data for read command;
+
+	if( !write) {
+		mdic = E1000_MDIC_OP_READ | (M88_GL2_SMI_DATA << E1000_MDIC_REG_SHIFT);
+		wr32(E1000_MDIC, mdic);
+		ret = igb_vc_mdio_wait(hw);
+		if(ret < 0)
+			goto out;
+		*data = ret;
+	}
+	ret = 0;
+out:
+	return(ret);
+}
+
+// read SMI MDIO registers;
+// of Marvell switch acting as SGMII/copper PHY;
+// the PHY registers cannot be accessed directly through bank;
+// instead, we must go through the SMI_CMD/SMI_DATA registers;
+// reg[4:0] register;
+// reg[9:5] device (copper 0..N, 0xf fiver);
+// reg[31:16] page;
+
+static s32
+igb_vc_smi_mdio_read(struct e1000_hw *hw, u32 reg, u16 *data)
+{
+	u32 mdic;
+	u16 page;
+	s32 ret;
+
+	// acquire MDIO interface;
+
+	ret = hw->phy.ops.acquire(hw);
+	if(ret)
+		return(ret);
+
+	// the phy address is now in MDICNFG;
+	// always overwrite PHY addr, since other device can share the bus;
+	// SMI_CMD/SMI_DATA are in GLOBAL2;
+
+	mdic = rd32(E1000_MDICNFG);
+	mdic &= (E1000_MDICNFG_EXT_MDIO | E1000_MDICNFG_COM_MDIO);
+	mdic |= (M88_SW_GLOBAL2 << E1000_MDIC_PHY_SHIFT);
+	wr32(E1000_MDICNFG, mdic);
+
+	// the smi interface should be available, no other contenders;
+
+	mdic = E1000_MDIC_OP_READ | (M88_GL2_SMI_CMD << E1000_MDIC_REG_SHIFT);
+	wr32(E1000_MDIC, mdic);
+	ret = igb_vc_mdio_wait(hw);
+	if(ret < 0)
+		goto out;
+	if(mdic & M88_GL2_SMI_CMD_BUSY) {
+		ret = -E1000_ERR_PHY;
+		goto out;
+	}
+
+	// issue smi command to set page;
+
+	page = reg >> 16;
+	ret = igb_vc_smi_cmd(hw, (reg & 0x3e0) | M88E1000_PHY_PAGE22, 1, &page);
+	if(ret)
+		goto out;
+
+	// issue smi read command;
+
+	ret = igb_vc_smi_cmd(hw, reg, 0, data);
+out:
+	hw->phy.ops.release(hw);
+	return(ret);
+}
+
+// write SMI MDIO registers;
+// of Marvell switch acting as SGMII/copper PHY;
+// the PHY registers cannot be accessed directly through bank;
+// instead, we must go through the SMI_CMD/SMI_DATA registers;
+// reg[4:0] register;
+// reg[9:5] device (copper 0..N, 0xf fiver);
+// reg[31:16] page;
+
+static s32
+igb_vc_smi_mdio_write(struct e1000_hw *hw, u32 reg, u16 data)
+{
+	u32 mdic;
+	u16 page;
+	s32 ret;
+
+	// acquire MDIO interface;
+
+	ret = hw->phy.ops.acquire(hw);
+	if(ret)
+		return(ret);
+
+	// the phy address is now in MDICNFG;
+	// always overwrite PHY addr, since other device can share the bus;
+	// SMI_CMD/SMI_DATA are in GLOBAL2;
+
+	mdic = rd32(E1000_MDICNFG);
+	mdic &= (E1000_MDICNFG_EXT_MDIO | E1000_MDICNFG_COM_MDIO);
+	mdic |= (M88_SW_GLOBAL2 << E1000_MDIC_PHY_SHIFT);
+	wr32(E1000_MDICNFG, mdic);
+
+	// the smi interface should be available, no other contenders;
+
+	mdic = E1000_MDIC_OP_READ | (M88_GL2_SMI_CMD << E1000_MDIC_REG_SHIFT);
+	wr32(E1000_MDIC, mdic);
+	ret = igb_vc_mdio_wait(hw);
+	if(ret < 0)
+		goto out;
+
+	// issue smi command to set page;
+
+	page = reg >> 16;
+	ret = igb_vc_smi_cmd(hw, (reg & 0x3e0) | M88E1000_PHY_PAGE22, 1, &page);
+	if(ret)
+		goto out;
+
+	// issue smi read command;
+
+	ret = igb_vc_smi_cmd(hw, reg, 1, &data);
+out:
+	hw->phy.ops.release(hw);
+	return(ret);
+}
+
+// read MDIO SGMII register;
+// on 88e6320 point to the serdes of the port;
+
+static s32
+igb_vc_m88sw_sgmii_mdio_read(struct e1000_hw *hw, u32 reg, u16 *data)
+{
+	s32 ret;
+
+	ret = igb_vc_smi_mdio_read(hw, (1 << 16) | (hw->phy.ports[e1000_port_sgmii] << 5) | reg, data);
+	vcdbg("%d/%d/%d = %d 0x%x\n", 1, hw->phy.ports[e1000_port_sgmii], reg & 0x1f, ret, *data);
+	return(ret);
+}
+
+// write MDIO SGMII register;
+// on 88e6320 point to the serdes of the port;
+
+static s32
+igb_vc_m88sw_sgmii_mdio_write(struct e1000_hw *hw, u32 reg, u16 data)
+{
+	s32 ret;
+
+	ret = igb_vc_smi_mdio_write(hw, (1 << 16) | (hw->phy.ports[e1000_port_sgmii] << 5) | reg, data);
+	vcdbg("%d/%d/%d = %d 0x%x\n", 1, hw->phy.ports[e1000_port_sgmii], reg & 0x1f, ret, data);
+	return(ret);
+}
+
+// read MDIO PHY register;
+// on 88e6320 point to the copper PHYs of the port;
+
+static s32
+igb_vc_m88sw_phy_mdio_read(struct e1000_hw *hw, u32 reg, u16 *data)
+{
+	s32 ret;
+
+	ret = igb_vc_smi_mdio_read(hw, (hw->phy.ports[e1000_port_phy] << 5) | reg, data);
+	vcdbg("%d/%d/%d = %d 0x%x\n", 0, hw->phy.ports[e1000_port_phy], reg, ret, *data);
+	return(ret);
+}
+
+// write MDIO PHY register;
+// on 88e6320 point to the copper PHYs of the port;
+
+static s32
+igb_vc_m88sw_phy_mdio_write(struct e1000_hw *hw, u32 reg, u16 data)
+{
+	s32 ret;
+
+	ret = igb_vc_smi_mdio_write(hw, (hw->phy.ports[e1000_port_phy] << 5) | reg, data);
+	vcdbg("%d/%d/%d = %d 0x%x\n", 0, hw->phy.ports[e1000_port_phy], reg, ret, data);
+	return(ret);
+}
+
+#if defined(IGB_VC_DUMP_6320) || defined(IGB_VC_DUMP_6176)
+
+// dump page of m88 switch regs;
+
+static void
+igb_dump_sw(struct e1000_hw *hw, int page)
+{
+	int reg, ret;
+	u16 data;
+
+	printk("%s %d\n", __func__, hw->bus.func);
+
+	for(reg = 0; reg < 32; reg++) {
+		ret = igb_vc_mdio_read(hw, M88_SW_REG(page, reg), &data);
+		if(ret)
+			continue;
+		printk(" reg%d/%d 0x%x\n", page, reg, data);
+	}
+}
+
+// dump page of m88 switch phy regs;
+
+static void
+igb_dump_swphy(struct e1000_hw *hw, u32 addr)
+{
+	int reg, ret;
+	u16 data;
+
+	printk("%s %d\n", __func__, hw->bus.func);
+
+	for(reg = 0; reg < 32; reg++) {
+		ret = igb_vc_smi_mdio_read(hw, addr | reg, &data);
+		if(ret)
+			continue;
+		printk(" phy%x/%d/%d 0x%x\n", addr >> 16, (addr >> 5) & 0x1f, reg, data);
+	}
+}
+
+#endif
+
+#if defined(IGB_VC_DUMP_1112)
+
+// dump page of m88 phy regs;
+
+static void
+igb_dump_phy(struct e1000_hw *hw, u16 page)
+{
+	int reg, ret;
+	u16 data;
+
+	printk("%s %d\n", __func__, hw->bus.func);
+
+	for(reg = 0; reg < 32; reg++) {
+		ret = igb_vc_mdio_read(hw, IGB_VC_PAGE | (page << 16) | reg, &data);
+		if(ret)
+			continue;
+		printk(" phy%x/%d 0x%x\n", page, reg & 0x1f, data);
+	}
+}
+
+#endif
+
+#if 0
+
+// software reset entire marvell switch;
+// XXX it doesn't really put the switch back into full hw reset;
+
+static s32
+igb_vc_m88sw_reset(struct e1000_hw *hw)
+{
+	s32 ret;
+	u16 sw_ctrl;
+
+	vcdbg("%d\n", hw->bus.func);
+	ret = igb_vc_mdio_read(hw,
+		M88_SW_REG(M88_SW_GLOBAL1, M88_SW_GL1_CTRL),
+		&sw_ctrl);
+	if(ret)
+		goto out;
+	sw_ctrl |= M88_SW_GL1_CTRL_SWRESET;
+	ret = igb_vc_mdio_write(hw,
+		M88_SW_REG(M88_SW_GLOBAL1, M88_SW_GL1_CTRL),
+		sw_ctrl);
+	udelay(1);
+out:    
+	return(ret);
+}
+
+#endif
+        
+// extra info for edge500;
+
+struct igb_vc_info {
+	u8 ports[e1000_n_phy_ports];
+	int (*func)(struct e1000_hw *, struct igb_vc_info *);
+};
+
+// probe Marvell switches as PHYs;
+// probe the product ID of the port registers;
+
+// 88e6320 uses single-chip addressing, ie. all device addresses used as bank select;
+// the 88e1112 is on the same MDIO bus, bus responds to address 0x7, which is
+// not used by the 88e6320, so both should coexist without conflicts;
+
+// 88e6176 uses single-chip addressing, ie. all device addresses used as bank select;
+
+static int
+igb_vc_m88sw_id(struct e1000_hw *hw, struct igb_vc_info *info)
+{
+	int ret;
+	u16 prod_id;
+
+	// read product ID from port;
+	// make up marvell PHY ID;
+
+	ret = igb_vc_mdio_read(hw,
+		M88_SW_PORT_REG(hw->phy.ports[e1000_port_cpu], M88_SW_PORT_PROD_ID),
+		&prod_id);
+	vcdbg("prod id  %d 0x%x\n", ret, prod_id);
+	if(ret == 0) {
+		hw->phy.id = (M88_VENDOR << 16) | (prod_id & PHY_REVISION_MASK);
+		hw->phy.revision = prod_id & ~PHY_REVISION_MASK;
+	}
+	return(ret);
+}
+
+// read standard PHY vendor and device IDs;
+
+static s32
+igb_vc_phy_id(struct e1000_hw *hw, struct igb_vc_info *info)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret;
+        u16 phy_id;
+
+	// use standard phy access functions;
+
+	phy->ops.read_reg = igb_read_phy_reg_82580;
+	phy->ops.write_reg = igb_write_phy_reg_82580;
+
+	// read phy ID;
+
+	ret = phy->ops.read_reg(hw, PHY_ID1, &phy_id);
+	if(ret)
+		goto out;
+	phy->id = phy_id << 16;
+	udelay(20);
+	ret = phy->ops.read_reg(hw, PHY_ID2, &phy_id);
+	if(ret)
+		goto out;
+	phy->id |= (phy_id & PHY_REVISION_MASK);
+	phy->revision = phy_id & ~PHY_REVISION_MASK;
+
+out:
+	return(ret);
+}
+
+// extra info to handle special PHYs;
+// unfortunatedly, we need to make this link dependent;
+// 0: 88e6320 port 0 (WAN0);
+// 1: 88e6176 port 4 (LAN switch);
+// 2: 88e6320 port 1 (WAN1);
+// 3: 88e1112 PHY (SFP);
+
+static struct igb_vc_info igb_vc_infos[] = {
+	{ { 0, 0xc, 3 }, igb_vc_m88sw_id, },
+	{ { 4, 0xf, 0 }, igb_vc_m88sw_id, },
+	{ { 1, 0xd, 4 }, igb_vc_m88sw_id, },
+	{ { 0, 0, 0 }, igb_vc_phy_id },
+};
+
+// get PHY id/rev;
+
+static s32
+igb_vc_get_swphy_id(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	struct igb_vc_info *info;
+	int (*func)(struct e1000_hw *, struct igb_vc_info *);
+	s32 ret;
+
+	// marvell switches may require special access functions,
+	// some of their MDIO bus decodes also vary, for example
+	// single- and multi-chip addressing modes;
+
+	if(hw->bus.func >= IGB_VC_N_BUS_FUNC)
+		return(-E1000_ERR_CONFIG);
+
+	info = igb_vc_infos + hw->bus.func;
+
+	phy->ports[e1000_port_cpu] = info->ports[e1000_port_cpu];
+	phy->ports[e1000_port_sgmii] = info->ports[e1000_port_sgmii];
+	phy->ports[e1000_port_phy] = info->ports[e1000_port_phy];
+
+	func = info->func;
+	ret = E1000_SUCCESS;
+	if(func)
+		ret = func(hw, info);
+	return(ret);
+}
+
+// reset cpu port serdes phy;
+
+static s32
+igb_vc_m88sw_sgmii_reset(struct e1000_hw *hw)
+{
+	s32 ret;
+	u16 ctrl;
+
+	// force auto-negotiation off;
+	// take out of power-down mode;
+
+	ret = igb_vc_m88sw_sgmii_mdio_read(hw, PHY_CONTROL, &ctrl);
+	if(ret)
+		goto out;
+	ctrl |= (MII_CR_RESET | MII_CR_FULL_DUPLEX);
+	ctrl &= ~(MII_CR_AUTO_NEG_EN | MII_CR_POWER_DOWN);
+	ret = igb_vc_m88sw_sgmii_mdio_write(hw, PHY_CONTROL, ctrl);
+        udelay(1);
+out:
+	return(ret);
+}
+
+// reset copper phy port;
+
+static s32
+igb_vc_m88sw_phy_reset(struct e1000_hw *hw)
+{
+	s32 ret;
+	u16 ctrl;
+
+	// take out of power-down mode;
+
+	ret = igb_vc_m88sw_phy_mdio_read(hw, PHY_CONTROL, &ctrl);
+	if(ret)
+		goto out;
+	ctrl |= MII_CR_RESET;
+	ctrl &= ~MII_CR_POWER_DOWN;
+	ret = igb_vc_m88sw_phy_mdio_write(hw, PHY_CONTROL, ctrl);
+        udelay(1);
+out:
+	return(ret);
+}
+
+// reset marvell switch ports;
+
+static s32
+igb_vc_m88sw_port_reset(struct e1000_hw *hw)
+{
+	s32 ret;
+
+	// reset the copper PHY;
+
+	ret = igb_vc_m88sw_phy_reset(hw);
+	if(ret)
+		goto out;
+
+	// reset the cpu port serdes;
+
+	ret = igb_vc_m88sw_sgmii_reset(hw);
+out:
+	return(ret);
+}
+
+// reset sfp port;
+
+static s32
+igb_vc_m88phy_sfp_reset(struct e1000_hw *hw)
+{
+	s32 ret;
+	u16 ctrl;
+
+	// reset the sfp side;
+
+	ret = igb_vc_m88phy_sfp_mdio_read(hw, PHY_CONTROL, &ctrl);
+	if(ret)
+		goto out;
+	ctrl &= ~MII_CR_POWER_DOWN;
+	ctrl |= MII_CR_RESET;
+	ret = igb_vc_m88phy_sfp_mdio_write(hw, PHY_CONTROL, ctrl);
+	if(ret)
+		goto out;
+
+	// reset the sgmii side;
+
+	ret = igb_vc_m88phy_sgmii_mdio_read(hw, PHY_CONTROL, &ctrl);
+	if(ret)
+		goto out;
+	ctrl &= ~MII_CR_POWER_DOWN;
+	ctrl |= MII_CR_RESET;
+	ret = igb_vc_m88phy_sgmii_mdio_write(hw, PHY_CONTROL, ctrl);
+out:
+	return(ret);
+}
+
+// setup sgmii link;
+// link needs to be forced due to MAC-MAC link;
+
+static s32
+igb_vc_setup_sgmii_link_forced(struct e1000_hw *hw)
+{
+	u32 cfg, ctrl, lctl;
+
+	// enable PCS;
+
+	cfg = rd32(E1000_PCS_CFG0);
+	cfg |= E1000_PCS_CFG_PCS_EN;
+	wr32(E1000_PCS_CFG0, cfg);
+
+	// SLU must be set to enable serdes;
+	// force speed and duplex;
+
+	ctrl = rd32(E1000_CTRL);
+	ctrl |= (E1000_CTRL_SLU
+		| E1000_CTRL_SPD_1000
+		| E1000_CTRL_FD
+		| E1000_CTRL_FRCSPD
+		| E1000_CTRL_FRCDPX);
+	wr32(E1000_CTRL, ctrl);
+	vcdbg("ctrl 0x%x\n", ctrl);
+
+	// force sgmii link;
+	// no auto-negotitation;
+
+	lctl = rd32(E1000_PCS_LCTL);
+	lctl &= ~(E1000_PCS_LCTL_AN_ENABLE
+		| E1000_PCS_LCTL_AN_RESTART
+		| E1000_PCS_LCTL_AN_TIMEOUT);
+	lctl |= (E1000_PCS_LCTL_FLV_LINK_UP
+		| E1000_PCS_LCTL_FSV_1000
+		| E1000_PCS_LCTL_FDV_FULL
+		| E1000_PCS_LCTL_FSD
+		| E1000_PCS_LCTL_FORCE_FCTRL
+		| E1000_PCS_LCTL_FORCE_LINK);
+	wr32(E1000_PCS_LCTL, lctl);
+	vcdbg("lctl 0x%x\n", lctl);
+
+	ctrl = rd32(E1000_PCS_LSTAT);
+	vcdbg("lsts 0x%x\n", ctrl);
+
+	return(E1000_SUCCESS);
+}
+
+// setup sgmii link for autoneg;
+
+static s32
+igb_vc_setup_sgmii_link_aneg(struct e1000_hw *hw)
+{
+	u32 cfg, ctrl, lctl, an;
+
+	// enable PCS;
+
+	cfg = rd32(E1000_PCS_CFG0);
+	cfg |= E1000_PCS_CFG_PCS_EN;
+	wr32(E1000_PCS_CFG0, cfg);
+
+	// set link up, clear forcing of speed and duplex;
+
+	ctrl = rd32(E1000_CTRL);
+	ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+	ctrl |= E1000_CTRL_SLU;
+	wr32(E1000_CTRL, ctrl);
+	vcdbg("ctrl 0x%x\n", ctrl);
+
+	// setup sgmii link for autoneg;
+
+	lctl = rd32(E1000_PCS_LCTL);
+	lctl &= ~(E1000_PCS_LCTL_AN_TIMEOUT
+		| E1000_PCS_LCTL_FLV_LINK_UP
+		| E1000_PCS_LCTL_FSD
+		| E1000_PCS_LCTL_FORCE_FCTRL
+		| E1000_PCS_LCTL_FORCE_LINK);
+	lctl |= (E1000_PCS_LCTL_AN_ENABLE
+		| E1000_PCS_LCTL_AN_RESTART);
+
+	// configure flow-control for autoneg;
+
+	an = rd32(E1000_PCS_ANADV);
+	an &= ~(E1000_TXCW_ASM_DIR | E1000_TXCW_PAUSE);
+
+	switch(hw->fc.requested_mode) {
+	case e1000_fc_full:
+	case e1000_fc_rx_pause:
+		an |= E1000_TXCW_ASM_DIR;
+		an |= E1000_TXCW_PAUSE;
+		break;
+	case e1000_fc_tx_pause:
+		an |= E1000_TXCW_ASM_DIR;
+		break;
+	default:
+		break;
+	}
+	wr32(E1000_PCS_ANADV, an);
+	vcdbg("an 0x%x\n", an);
+
+	wr32(E1000_PCS_LCTL, lctl);
+	vcdbg("lctl 0x%x\n", lctl);
+
+	ctrl = rd32(E1000_PCS_LSTAT);
+	vcdbg("lsts 0x%x\n", ctrl);
+
+	return(E1000_SUCCESS);
+}
+
+// enable forwarding on port;
+
+static s32
+igb_vc_m88sw_port_fwd(struct e1000_hw *hw, u8 port)
+{
+	s32 ret;
+	u16 ctrl;
+
+	ret = igb_vc_mdio_read(hw,
+		M88_SW_PORT_REG(port, M88_SW_PORT_CONTROL), &ctrl);
+	if(ret)
+		goto out;
+	ctrl |= M88_SW_PORT_CONTROL_FWD;
+	ret = igb_vc_mdio_write(hw,
+		M88_SW_PORT_REG(port, M88_SW_PORT_CONTROL), ctrl);
+out:
+	return(ret);
+}
+
+// setup link to a Marvell switch 88e6320;
+// switch is used as dual copper PHY;
+
+static s32
+igb_vc_setup_link_m88e6320(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret;
+	u16 fid;
+
+	// setup the sgmii link;
+
+	ret = igb_vc_setup_sgmii_link_forced(hw);
+	if(ret)
+		goto out;
+
+	// the NO_CPU pin is pulled low to disable switch after reset,
+	// to make sure no packets flow between WAN ports;
+	// reset the copper and serdes PHYs;
+	// this takes them out of power-down mode;
+
+	ret = phy->ops.reset(hw); 
+	if(ret)
+		goto out;
+
+	// setup port-based routing;
+	// the two WAN ports are different networks;
+	// cpu can send to phy port;
+	// phy can send to cpu port;
+	// set different filter ID per vlan for MAC addr handling;
+
+	fid = hw->bus.func << 12;
+
+	ret = igb_vc_mdio_write(hw,
+		M88_SW_PORT_REG(phy->ports[e1000_port_cpu], M88_SW_PORT_VLAN_MAP),
+		fid | (1 << phy->ports[e1000_port_phy]));
+	if(ret)
+		goto out;
+	ret = igb_vc_mdio_write(hw,
+		M88_SW_PORT_REG(phy->ports[e1000_port_phy], M88_SW_PORT_VLAN_MAP),
+		fid | (1 << phy->ports[e1000_port_cpu]));
+	if(ret)
+		goto out;
+
+	// above reset took the PHYs out of power-down;
+	// the ports are still disabled, so enable forwarding;
+
+	ret = igb_vc_m88sw_port_fwd(hw, phy->ports[e1000_port_cpu]);
+	if(ret)
+		goto out;
+	ret = igb_vc_m88sw_port_fwd(hw, phy->ports[e1000_port_phy]);
+	if(ret)
+		goto out;
+
+#ifdef IGB_VC_DUMP_6320
+{
+	u32 ctrl;
+
+	//igb_dump_sw(hw, M88_SW_GLOBAL1);
+	igb_dump_sw(hw, M88_SW_PORT_BASE + phy->ports[e1000_port_cpu]);
+	igb_dump_swphy(hw, (1 << 16) | (phy->ports[e1000_port_sgmii] << 5));
+	igb_dump_sw(hw, M88_SW_PORT_BASE + phy->ports[e1000_port_phy]);
+	igb_dump_swphy(hw, (0 << 16) | (phy->ports[e1000_port_phy] << 5));
+
+	ctrl = rd32(E1000_STATUS);
+	printk("%s status 0x%x\n", __func__, ctrl);
+}
+#endif
+
+out:
+	vcdbg("ret %d\n", ret);
+	return(ret);
+}
+
+// setup link to a Marvell switch 88e6176;
+// switch is a SGMII attached switch to 4 copper PHYs;
+
+static s32
+igb_vc_setup_link_m88e6176(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret;
+	u16 data;
+
+	// setup the sgmii link;
+
+	ret = igb_vc_setup_sgmii_link_forced(hw);
+	if(ret)
+		goto out;
+
+	// reset the serdes PHYs;
+
+	ret = phy->ops.reset(hw); 
+	if(ret)
+		goto out;
+
+	// clear the sw port PHYDetect bit;
+
+	ret = igb_vc_mdio_read(hw,
+		M88_SW_PORT_REG(phy->ports[e1000_port_cpu], M88_SW_PORT_STATUS),
+		&data);
+	if(ret)
+		goto out;
+	data &= ~M88_SW_PORT_STATUS_PHYDET;
+	ret = igb_vc_mdio_write(hw,
+		M88_SW_PORT_REG(phy->ports[e1000_port_cpu], M88_SW_PORT_STATUS),
+		data);
+	if(ret)
+		goto out;
+
+#ifdef IGB_VC_DUMP_6176
+{
+	u32 ctrl;
+
+	//igb_dump_sw(hw, M88_SW_GLOBAL1);
+	igb_dump_sw(hw, M88_SW_PORT_BASE + 4);
+	igb_dump_swphy(hw, (1 << 16) | (0xf << 5));
+	igb_dump_swphy(hw, (0 << 16) | (0 << 5));
+	igb_dump_swphy(hw, (0 << 16) | (1 << 5));
+	igb_dump_swphy(hw, (0 << 16) | (2 << 5));
+	igb_dump_swphy(hw, (0 << 16) | (3 << 5));
+
+	ctrl = rd32(E1000_STATUS);
+	printk("%s status 0x%x\n", __func__, ctrl);
+}
+#endif
+
+out:
+	vcdbg("ret %d\n", ret);
+	return(ret);
+}
+
+// setup link to a Marvell switch 88e1112;
+// PHY to SFP cage, which is always powered;
+
+static s32
+igb_vc_setup_link_m88e1112(struct e1000_hw *hw)
+{
+	u16 data;
+	s32 ret;
+
+	// setup the sgmii link;
+
+	ret = igb_vc_setup_sgmii_link_aneg(hw);
+	if(ret)
+		goto out;
+
+	// set polarity of SIGDET;
+	// this is retained across a sw reset;
+
+	ret = igb_vc_m88phy_sfp_mdio_read(hw, M88E1000_PHY_SPEC_CTRL, &data);
+	if(ret)
+		goto out;
+	data |= M88E1000_SPEC_CTRL_SIGDET;
+	ret = igb_vc_m88phy_sfp_mdio_write(hw, M88E1000_PHY_SPEC_CTRL, data);
+	if(ret)
+		goto out;
+
+	// reset the PHYs;
+
+	ret = hw->phy.ops.reset(hw); 
+	if(ret)
+		goto out;
+
+	// set sgmii mode;
+	// after reset, as it is not retained;
+
+	ret = igb_vc_m88phy_sgmii_mdio_read(hw, M88E1000_PHY_SPEC_CTRL, &data);
+	if(ret)
+		goto out;
+	data &= ~(M88E1000_SPEC_CTRL_PREFER
+		| M88E1000_SPEC_CTRL_MODE);
+	data |= (M88E1000_SPEC_CTRL_MODE_1000BASEX_ONLY
+		| M88E1000_SPEC_CTRL_PWR_UP
+		| M88E1000_SPEC_CTRL_ENH_SGMII);
+	ret = igb_vc_m88phy_sgmii_mdio_write(hw, M88E1000_PHY_SPEC_CTRL, data);
+	if(ret)
+		goto out;
+
+#ifdef IGB_VC_DUMP_1112
+{
+	u32 ctrl;
+
+	igb_dump_phy(hw, 2);
+	igb_dump_phy(hw, 1);
+
+	ctrl = rd32(E1000_PCS_LCTL);
+	printk("%s lctl 0x%x\n", __func__, ctrl);
+	ctrl = rd32(E1000_PCS_LSTAT);
+	printk("%s lsts 0x%x\n", __func__, ctrl);
+	ctrl = rd32(E1000_STATUS);
+	printk("%s status 0x%x\n", __func__, ctrl);
+}
+#endif
+
+out:
+	vcdbg("ret %d\n", ret);
+	return(ret);
+}
+
+// get phy info of Marvell switch 88e6176;
+// the switch is SGMII attached, so there isn't really a PHY;
+// return the info from the port registers;
+
+static s32
+igb_vc_m88sw_get_phy_info(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret;
+	u16 status;
+
+	// read switch's port status;
+
+	ret = igb_vc_mdio_read(hw,
+		M88_SW_PORT_REG(phy->ports[e1000_port_cpu], M88_SW_PORT_STATUS),
+		&status);
+	vcdbg("ret %d\n", ret);
+	if(ret)
+		goto out;
+
+	phy->is_mdix = false;
+	if(status & M88_SW_PORT_STATUS_LINK_UP) {
+		phy->local_rx = e1000_1000t_rx_status_ok;
+		phy->remote_rx = e1000_1000t_rx_status_ok;
+	} else {
+		phy->local_rx = e1000_1000t_rx_status_not_ok;
+		phy->remote_rx = e1000_1000t_rx_status_not_ok;
+	}
+
+out:
+	return(ret);
+}
+
+// check that sgmii link is up;
+// returns <0 for error, 0 no link, 1 has link;
+
+static s32
+igb_vc_sgmii_check_for_link(struct e1000_hw *hw)
+{
+	s32 ret;
+	u16 speed, duplex;
+
+	// need to check the PCS, not a PHY;
+
+	ret = igb_get_pcs_speed_and_duplex_82575(hw, &speed, &duplex);
+	if(ret)
+		goto out;
+
+#ifdef XXX
+                /* Configure Flow Control now that Auto-Neg has completed.
+                 * First, we need to restore the desired flow control
+                 * settings because we may have had to re-autoneg with a
+                 * different link partner.
+                 */
+                ret_val = igb_config_fc_after_link_up(hw);
+                if (ret_val)
+                        hw_dbg("Error configuring flow control\n");
+#endif
+
+	ret = hw->mac.serdes_has_link;
+	vcdbg("serdes %d\n", ret);
+
+out:
+	return(ret);
+}
+
+// check for link to a marvell switch;
+// only checks for the sgmii link to the switch,
+// not any media connections on other switch ports;
+// for m88e6176, MAC interrupt turns on link checking when sgmii is down;
+
+static s32
+igb_vc_m88sw_check_for_link(struct e1000_hw *hw)
+{
+	s32 ret = 0;
+	u16 portsts;
+
+	// only check link when we want;
+
+	if( !hw->mac.get_link_status)
+		goto out;
+
+	// check if sgmii link is up;
+
+	ret = igb_vc_sgmii_check_for_link(hw);
+	if(ret <= 0)
+		goto out;
+
+	// read switch port status register;
+
+	ret = igb_vc_mdio_read(hw,
+		M88_SW_PORT_REG(hw->phy.ports[e1000_port_cpu], M88_SW_PORT_STATUS),
+		&portsts);
+	vcdbg("port status %d 0x%x\n", ret, portsts);
+	if(ret)
+		goto out;
+
+	if( !(portsts & M88_SW_PORT_STATUS_LINK_UP))
+		goto out;
+	hw->mac.get_link_status = false;
+
+out:
+	return(ret);
+}
+
+// check for link on m88e6320;
+// need to always check the copper PHYs, because we have no intr from the chip;
+// then check the sgmii link, only if link is down;
+
+static s32
+igb_vc_m88sw_check_for_link_m88e6320(struct e1000_hw *hw)
+{
+	s32 ret;
+	u16 portsts;
+
+	// always check port status;
+
+	ret = igb_vc_mdio_read(hw,
+		M88_SW_PORT_REG(hw->phy.ports[e1000_port_phy], M88_SW_PORT_STATUS),
+		&portsts);
+	vcdbg("port status %d 0x%x\n", ret, portsts);
+	if(ret)
+		goto out;
+
+	// re-poll when copper link is down;
+
+	if( !(portsts & M88_SW_PORT_STATUS_LINK_UP)) {
+		hw->mac.get_link_status = true;
+		goto out;
+	}
+
+	// now, check sgmii;
+
+	ret = igb_vc_m88sw_check_for_link(hw);
+out:
+	return(ret);
+}
+
+// read a block of bytes from sfp i2c;
+
+static int
+igb_vc_i2c_read(struct i2c_client *client, u32 off, u32 len, u8 *buf)
+{
+	int ret = 0;
+
+	for(; len; off++, len--) {
+		ret = i2c_smbus_read_byte_data(client, off);
+		if(ret < 0)
+			break;
+		*buf++ = (u8)ret;
+	}
+	return((ret < 0)? ret : 0);
+}
+
+// strip trailing spaces from strings;
+
+static void
+igb_vc_strip_tspc(u32 len, u8 *str)
+{
+	u8 *s = str + len;
+
+	for(*s = 0; len-- && (*--s == ' '); *s = 0);
+}
+
+// probe sfp cage i2c;
+// called for each i2c device after detecting, by the i2c core;
+// much of the probing has been done in detect;
+
+static int
+igb_vc_sfp_probe(struct e1000_hw *hw)
+{
+	struct vc_i2c_sfp *sfp = &igb_vc_i2c_sfp;
+	struct i2c_client *client = sfp->client[SFP_EEPROM];
+	struct igb_adapter *adapter = sfp->adapter;
+	struct pci_dev *pdev = adapter->pdev;
+	int ret;
+
+	// re-probe i2c if no device detected yet;
+
+	sfp->plugged = false;
+	if( !client) {
+		igb_vc_i2c_exit(adapter);
+		ret = igb_vc_i2c_init(adapter);
+		if(ret < 0)
+			return(ret);
+		client = sfp->client[SFP_EEPROM];
+	}
+	if( !client)
+		return(-ENODEV);
+
+	// read sfp/sff identifier;
+
+	ret = i2c_smbus_read_byte_data(client, SFP_OFF_IDENTIFIER);
+	if(ret < 0)
+		return(ret);
+	if(ret != SFP_IDENTIFIER_SFP) {
+		dev_err(&pdev->dev, "non-SFP identifier: 0x%x\n", ret);
+		return(-ENODEV);
+	}
+
+	// read vendor/oui/part;
+
+	ret = igb_vc_i2c_read(client, SFP_OFF_VENDOR, SFP_SIZE_VENDOR, sfp->vendor);
+	if(ret < 0)
+		goto out;
+	ret = igb_vc_i2c_read(client, SFP_OFF_OUI, SFP_SIZE_OUI, sfp->oui);
+	if(ret < 0)
+		goto out;
+	ret = igb_vc_i2c_read(client, SFP_OFF_PARTNUM, SFP_SIZE_PARTNUM, sfp->partnum);
+	if(ret < 0)
+		goto out;
+
+	// log sfp module info;
+
+	igb_vc_strip_tspc(SFP_SIZE_VENDOR, sfp->vendor);
+	igb_vc_strip_tspc(SFP_SIZE_PARTNUM, sfp->partnum);
+	dev_info(&pdev->dev, "sfp vendor=%s oui=%02x:%02x:%02x part=%s\n",
+		sfp->vendor,
+		sfp->oui[0], sfp->oui[1], sfp->oui[2],
+		sfp->partnum);
+	sfp->plugged = true;
+	ret = 0;
+out:
+	return(ret);
+}
+
+// check for link on m88e1112 SFP;
+
+static s32
+igb_vc_m88phy_check_for_link_m88e1112(struct e1000_hw *hw)
+{
+	struct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;
+	s32 ret;
+	u16 status;
+
+	// check if sfp side has link;
+	// some PHYs require double read to update;
+	// force re-probing of sfp i2c when link is down;
+
+	igb_vc_m88phy_sfp_mdio_read(hw, PHY_STATUS, &status);
+	ret = igb_vc_m88phy_sfp_mdio_read(hw, PHY_STATUS, &status);
+	if(ret)
+		goto out;
+	if( !(status & MII_SR_LINK_STATUS)) {
+		hw->mac.get_link_status = true;
+		dev_spec->module_plugged = false;
+		goto out;
+	}
+
+	// check sfp i2c;
+	// do this after sfp phy is up, so something must be plugged in;
+
+	if(dev_spec->module_plugged == false) {
+		ret = igb_vc_sfp_probe(hw);
+		if(ret) {
+			ret = -E1000_ERR_I2C;
+			goto out;
+		}
+		dev_spec->module_plugged = true;
+	}
+
+	// check if sgmii link is up;
+
+	ret = igb_vc_sgmii_check_for_link(hw);
+	if(ret <= 0)
+		goto out;
+
+	hw->mac.get_link_status = false;
+	ret = E1000_SUCCESS;
+out:
+	return(ret);
+}
+
+// dummy check polarity;
+
+static s32
+igb_vc_dummy_check_polarity(struct e1000_hw *hw)
+{
+	return(E1000_SUCCESS);
+}
+
+// dummy get cable length;
+
+static s32
+igb_vc_dummy_get_cable_length(struct e1000_hw *hw)
+{
+	hw->phy.cable_length = 1;
+	return(E1000_SUCCESS);
+}
+
+// bug on force speed/duplex;
+
+static s32
+igb_vc_bugon_phy_force_speed_duplex(struct e1000_hw *hw)
+{
+	BUG_ON(1);
+	return(-E1000_ERR_PHY);
+}
+
+// probe for velocloud board;
+// using eeprom customer words 0x6/0x7;
+
+#define VC_ID 0x5663	// "Vc"
+#define VC_ID_EDGE500 0x6535 // "e5" - edge500;
+
+s32
+igb_vc_probe(struct e1000_hw *hw)
+{
+	struct igb_adapter *adapter = hw->back;
+	struct e1000_mac_info *mac = &hw->mac;
+	struct e1000_phy_info *phy = &hw->phy;
+	u32 mdic;
+	s32 ret = -E1000_ERR_PHY;
+	u16 eeprom[2];
+
+	// only bother about Rangeley MACs;
+	// only support is for SGMII attached with MDIO;
+
+	if(hw->mac.type != e1000_i354)
+		goto out;
+        if( !igb_sgmii_active_82575(hw))
+		goto out;
+	if( !igb_sgmii_uses_mdio_82575(hw))
+		goto out;
+
+	// check eeprom customer words;
+
+	eeprom[0] = eeprom[1] = 0;
+	hw->nvm.ops.read(hw, 0x06, 2, eeprom);
+	if(eeprom[0] != VC_ID)
+		goto out;
+
+	switch(eeprom[1]) {
+	case VC_ID_EDGE500:
+		break;
+	default:
+		goto out;
+	}
+	dev_info(&adapter->pdev->dev, "found custom link: 0x%x\n", eeprom[1]);
+
+	// do all the work of init_phy_param() here;
+
+        hw->bus.func = (rd32(E1000_STATUS) & E1000_STATUS_FUNC_MASK) >> E1000_STATUS_FUNC_SHIFT;
+
+	// get PHY address from MDICNFG;
+	// this assumes the EEPROM has valid config data;
+
+	mdic = rd32(E1000_MDICNFG);
+	mdic &= E1000_MDICNFG_PHY_MASK;
+	phy->addr = mdic >> E1000_MDICNFG_PHY_SHIFT;
+
+	// get the switch/PHY IDs;
+
+	ret = igb_vc_get_swphy_id(hw);
+	vcdbg("id 0x%x rev 0x%x\n", phy->id, phy->revision);
+	if(ret)
+		goto out;
+
+	// set phy handlers;
+
+	phy->reset_delay_us = 100;
+
+	switch(phy->id) {
+	case M88E6320_ID:
+		mac->autoneg = false;
+		mac->ops.setup_physical_interface = igb_vc_setup_link_m88e6320;
+		mac->ops.check_for_link = igb_vc_m88sw_check_for_link_m88e6320;
+		//mac->ops.get_speed_and_duplex = igb_vc_m88sw_get_speed_and_duplex;
+
+		phy->media_type = e1000_media_type_switch;
+		phy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;
+		phy->type = e1000_phy_m88sw;
+
+		phy->ops.read_reg = igb_vc_m88sw_phy_mdio_read;
+		phy->ops.write_reg = igb_vc_m88sw_phy_mdio_write;
+		phy->ops.reset = igb_vc_m88sw_port_reset;
+		phy->ops.check_polarity = igb_check_polarity_m88;
+		phy->ops.get_cable_length = igb_get_cable_length_m88_gen2;
+		phy->ops.force_speed_duplex = igb_vc_bugon_phy_force_speed_duplex; //XXX
+		phy->ops.get_phy_info = igb_vc_m88sw_get_phy_info;
+		break;
+
+	case M88E6176_ID:
+		mac->autoneg = false;
+		mac->ops.setup_physical_interface = igb_vc_setup_link_m88e6176;
+		mac->ops.check_for_link = igb_vc_m88sw_check_for_link;
+		mac->ops.get_speed_and_duplex = igb_get_pcs_speed_and_duplex_82575;
+
+		phy->media_type = e1000_media_type_switch;
+		phy->autoneg_mask = 0;
+		phy->type = e1000_phy_m88sw;
+
+		phy->ops.read_reg = igb_vc_m88sw_sgmii_mdio_read;
+		phy->ops.write_reg = igb_vc_m88sw_sgmii_mdio_write;
+		phy->ops.reset = igb_vc_m88sw_sgmii_reset;
+		phy->ops.check_polarity = igb_vc_dummy_check_polarity;
+		phy->ops.get_cable_length = igb_vc_dummy_get_cable_length;
+		phy->ops.force_speed_duplex = igb_vc_bugon_phy_force_speed_duplex;
+		phy->ops.get_phy_info = NULL;
+		break;
+
+	case M88E1112_ID:
+		mac->autoneg = true;
+		mac->ops.setup_physical_interface = igb_vc_setup_link_m88e1112;
+		mac->ops.check_for_link = igb_vc_m88phy_check_for_link_m88e1112;
+		mac->ops.get_speed_and_duplex = igb_get_pcs_speed_and_duplex_82575;
+
+		phy->media_type = e1000_media_type_sfp;
+		phy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;
+		phy->type = e1000_phy_m88;
+
+		phy->ops.read_reg = igb_vc_m88phy_sfp_mdio_read;
+		phy->ops.write_reg = igb_vc_m88phy_sfp_mdio_write;
+		phy->ops.reset = igb_vc_m88phy_sfp_reset;
+		phy->ops.check_polarity = NULL;
+		phy->ops.get_cable_length = NULL;
+		phy->ops.force_speed_duplex = igb_vc_bugon_phy_force_speed_duplex;
+		phy->ops.get_phy_info = NULL;
+		break;
+
+	default:
+		ret = -E1000_ERR_PHY;
+	}
+out:
+	return(ret);
+}
+
+// show sfp attributes;
+
+static ssize_t
+igb_vc_sfp_vendor_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct vc_i2c_sfp *sfp = &igb_vc_i2c_sfp;
+	ssize_t ret = -ENODEV;
+
+	if(sfp->client[SFP_EEPROM] && sfp->plugged)
+		ret = scnprintf(buf, PAGE_SIZE, "%s\n", sfp->vendor);
+        return(ret);
+}
+
+static ssize_t
+igb_vc_sfp_oui_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct vc_i2c_sfp *sfp = &igb_vc_i2c_sfp;
+	ssize_t ret = -ENODEV;
+
+	if(sfp->client[SFP_EEPROM] && sfp->plugged)
+		ret = scnprintf(buf, PAGE_SIZE, "%02x:%02x:%02x\n", sfp->oui[0], sfp->oui[1], sfp->oui[2]);
+        return(ret);
+}
+
+static ssize_t
+igb_vc_sfp_partnum_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct vc_i2c_sfp *sfp = &igb_vc_i2c_sfp;
+	ssize_t ret = -ENODEV;
+
+	if(sfp->client[SFP_EEPROM] && sfp->plugged)
+		ret = scnprintf(buf, PAGE_SIZE, "%s\n", sfp->partnum);
+        return(ret);
+}
+
+// all sfp attributes;
+
+static DEVICE_ATTR(vendor, S_IRUGO, igb_vc_sfp_vendor_show, NULL);
+static DEVICE_ATTR(oui, S_IRUGO, igb_vc_sfp_oui_show, NULL);
+static DEVICE_ATTR(partnum, S_IRUGO, igb_vc_sfp_partnum_show, NULL);
+
+static struct attribute *igb_vc_sfp_attrs[] = {
+	&dev_attr_vendor.attr,
+	&dev_attr_oui.attr,
+	&dev_attr_partnum.attr,
+	NULL,
+};
+
+static struct attribute_group igb_vc_sfp_group = {
+	.name = IGB_VC_SFP,
+	.attrs = igb_vc_sfp_attrs,
+};
+
+// detect i2c devices;
+// called for each i2c device before probing, by the i2c core;
+// device addresses are in struct i2c_driver.address_list;
+
+static int
+igb_vc_i2c_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if( !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA
+		| I2C_FUNC_SMBUS_WRITE_BYTE)) {
+		pr_err("igb: i2c adaptor does not support required smbus/i2c modes\n");
+		return(-ENODEV);
+	}
+
+	// success;
+
+	strlcpy(info->type, IGB_VC_SFP, I2C_NAME_SIZE);
+	return(0);
+}
+
+// probe sfp cage i2c;
+// called for each i2c device after detecting, by the i2c core;
+// the sfp may not be plugegd in yet, not much to do here;
+
+static int
+igb_vc_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct vc_i2c_sfp *sfp = &igb_vc_i2c_sfp;
+	struct igb_adapter *adapter = sfp->adapter;
+	struct pci_dev *pdev = adapter->pdev;
+	int ret = -ENODEV;
+
+	// EEPROM probe;
+	// create sysfs entries for sfp info;
+
+	if(client->addr == igb_vc_i2c_addrs[0]) {
+		sfp->client[SFP_EEPROM] = client;
+		ret = sysfs_create_group(&pdev->dev.kobj, &igb_vc_sfp_group);
+        	if(ret < 0)
+                	dev_err(&pdev->dev, "couldn't register sfp sysfs group\n");
+	}
+
+	// DMI probe;
+
+	if(client->addr == igb_vc_i2c_addrs[1]) {
+		sfp->client[SFP_DMI] = client;
+		ret = 0;
+	}
+
+	return(ret);
+}
+
+// remove driver;
+
+static int
+igb_vc_i2c_remove(struct i2c_client *client)
+{
+	struct vc_i2c_sfp *sfp = &igb_vc_i2c_sfp;
+	struct igb_adapter *adapter = sfp->adapter;
+
+	// remove sysfs entries;
+
+	sysfs_remove_group(&adapter->pdev->dev.kobj, &igb_vc_sfp_group);
+
+	sfp->client[SFP_EEPROM] = NULL;
+	sfp->client[SFP_DMI] = NULL;
+	return(0);
+}
+
+// i2c device id;
+
+static const struct i2c_device_id igb_vc_i2c_id[] = {
+	{ IGB_VC_SFP, 0 },
+	{},
+};
+
+// i2c driver struct;
+// can't have module_i2c_driver(vc_i2c_driver);
+
+static struct i2c_driver igb_vc_i2c_driver = {
+	.class = I2C_CLASS_HWMON,
+	.driver = {
+		.name = IGB_VC_SFP,
+	},
+	.address_list = igb_vc_i2c_addrs,
+	.probe = igb_vc_i2c_probe,
+	.remove = igb_vc_i2c_remove,
+	.id_table = igb_vc_i2c_id,
+	.detect = igb_vc_i2c_detect,
+};
+
+// init i2c to sfp;
+// sfp is on port 3;
+
+s32
+igb_vc_i2c_init(struct igb_adapter *adapter)
+{
+	struct vc_i2c_sfp *sfp = &igb_vc_i2c_sfp;
+	struct e1000_hw *hw = &adapter->hw;
+	int ret;
+
+	if(hw->bus.func != IGB_VC_SFP_BUS_FUNC)
+		return(0);
+
+	sfp->adapter = adapter;
+
+	ret = i2c_add_driver(&igb_vc_i2c_driver);
+	return(ret);
+}
+
+// free i2c to sfp;
+
+void
+igb_vc_i2c_exit(struct igb_adapter *adapter)
+{
+	struct e1000_hw *hw = &adapter->hw;
+
+	if(hw->bus.func != IGB_VC_SFP_BUS_FUNC)
+		return;
+
+	i2c_del_driver(&igb_vc_i2c_driver);
+}
+
+// dsa interface to m88e7176 switch;
+// cannot use mv88e6xxx driver as mdio bus access, mdio locking,
+// and m88e6176 phy register access are different;
+// much code copied from the marvell driver;
+
+#define REG_DIRECT	0x10
+#define REG_PORT(p)	(REG_DIRECT + (p))
+#define REG_GLOBAL	0x1b
+#define REG_GLOBAL2	0x1c
+
+struct m88e6176_priv {
+	struct mutex stats;	// serialize stats access;
+	int id;			// switch id;
+};
+
+struct m88e6176_hw_stat {
+	char string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int reg;
+};
+
+// read switch register;
+
+static int
+m88e6176_reg_read(struct dsa_switch *ds, int addr, int reg)
+{
+	struct mii_bus *bus = ds->master_mii_bus;
+	struct vc_dsa_priv *priv = bus->priv;
+	struct e1000_hw *hw = priv->hw;
+	int ret = -EINVAL;
+	u16 data;
+
+	if(addr >= REG_DIRECT)
+		ret = igb_vc_mdio_read(hw, (addr << 5) | reg, &data);
+	vcdsareg("%d addr %d reg %d data 0x%x\n", ret, addr, reg, data);
+	return(ret? ret : data);
+}
+
+// write switch register;
+
+static int
+m88e6176_reg_write(struct dsa_switch *ds, int addr, int reg, u16 val)
+{
+	struct mii_bus *bus = ds->master_mii_bus;
+	struct vc_dsa_priv *priv = bus->priv;
+	struct e1000_hw *hw = priv->hw;
+	int ret = -EINVAL;
+
+	if(addr >= REG_DIRECT)
+		ret = igb_vc_mdio_write(hw, (addr << 5) | reg, val);
+	vcdsareg("%d addr %d reg %d data 0x%x\n", ret, addr, reg, val);
+	return(ret);
+}
+
+// read phy register;
+
+static int
+m88e6176_phy_read(struct dsa_switch *ds, int port, int reg)
+{
+	struct mii_bus *bus = ds->master_mii_bus;
+	struct vc_dsa_priv *priv = bus->priv;
+	struct e1000_hw *hw = priv->hw;
+	int addr = port;
+	int ret = -EINVAL;
+	u16 data;
+
+	if(addr < 4)
+		ret = igb_vc_smi_mdio_read(hw, (addr << 5) | reg, &data);
+	vcdsaphy("%d addr %d reg %d data 0x%x\n", ret, addr, reg, data);
+	return(ret? ret : data);
+}
+
+// write phy register;
+
+static int
+m88e6176_phy_write(struct dsa_switch *ds, int port, int reg, u16 val)
+{
+	struct mii_bus *bus = ds->master_mii_bus;
+	struct vc_dsa_priv *priv = bus->priv;
+	struct e1000_hw *hw = priv->hw;
+	int addr = port;
+	int ret = -EINVAL;
+
+	if(addr < 4)
+		ret = igb_vc_smi_mdio_write(hw, (addr << 5) | reg, val);
+	vcdsaphy("%d addr %d reg %d data 0x%x\n", ret, addr, reg, val);
+	return(ret);
+}
+
+// set MAC address;
+
+static int
+m88e6176_set_addr(struct dsa_switch *ds, u8 *addr)
+{
+	int ret;
+	int i, j;
+
+	for(i = 0; i < 6; i++) {
+		ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x0d, 0x8000 | (i << 8) | addr[i]);
+		if(ret)
+			return(ret);
+
+		// wait for write to complete;
+		for(j = 0; j < 16; j++) {
+			ret = m88e6176_reg_read(ds, REG_GLOBAL2, 0x0d);
+			if(ret < 0)
+				return(ret);
+			if((ret & 0x8000) == 0)
+				break;
+		}
+		if(j == 16)
+			return(-ETIMEDOUT);
+	}
+	return(0);
+}
+
+// poll a link;
+
+static void
+m88e6176_poll_link(struct dsa_switch *ds)
+{
+	int i;
+	struct net_device *dev;
+	int sts, link, speed, duplex, fc;
+
+	for(i = 0; i < DSA_MAX_PORTS; i++) {
+		dev = ds->ports[i];
+		if(dev == NULL)
+			continue;
+
+		link = sts = 0;
+		if(dev->flags & IFF_UP) {
+			sts = m88e6176_reg_read(ds, REG_PORT(i), 0x00);
+			if(sts < 0)
+				continue;
+			link = !!(sts & 0x0800);
+		}
+
+		if( !link) {
+			if(netif_carrier_ok(dev)) {
+				netdev_info(dev, "link down\n");
+				netif_carrier_off(dev);
+			}
+			continue;
+		}
+
+		switch(sts & 0x0300) {
+		case 0x0000: speed = 10; break;
+		case 0x0100: speed = 100; break;
+		case 0x0200: speed = 1000; break;
+		default: speed = -1; break;
+		}
+		duplex = (sts & 0x0400)? 1 : 0;
+		fc = (sts & 0x8000)? 1 : 0;
+
+		if( !netif_carrier_ok(dev)) {
+			netdev_info(dev,
+				"link up, %d Mb/s, %s duplex, flow control %sabled\n",
+				speed, duplex? "full" : "half", fc? "en" : "dis");
+			netif_carrier_on(dev);
+		}
+	}
+}
+
+// wait for stats to be ready;
+
+static int
+m88e6176_stats_wait(struct dsa_switch *ds)
+{
+	int ret;
+	int i;
+
+	for(i = 0; i < 10; i++) {
+		ret = m88e6176_reg_read(ds, REG_GLOBAL, 0x1d);
+		if(ret < 0)
+			return(ret);
+		if( !(ret & 0x8000))
+			return(0);
+	}
+	return(-ETIMEDOUT);
+}
+
+// take a snapshot of the stats;
+
+static int
+m88e6176_stats_snapshot(struct dsa_switch *ds, int port)
+{
+	int ret;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x1d, 0xdc00 | ((port + 1) << 5));
+	if(ret == 0)
+		ret = m88e6176_stats_wait(ds);
+	return(ret);
+}
+
+// read a single stat;
+
+static int
+m88e6176_stats_read(struct dsa_switch *ds, int stat, u32 *valp)
+{
+	int ret;
+	u32 val;
+
+	*valp = 0;
+
+	// which stat to read;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x1d, 0xcc00 | stat);
+	if(ret)
+		goto out;
+	ret = m88e6176_stats_wait(ds);
+	if(ret < 0)
+		goto out;
+
+	// read high and low word;
+
+	ret = m88e6176_reg_read(ds, REG_GLOBAL, 0x1e);
+	if(ret < 0)
+		goto out;
+	val = ret << 16;
+	ret = m88e6176_reg_read(ds, REG_GLOBAL, 0x1f);
+	if(ret < 0)
+		goto out;
+	val |= ret;
+	*valp = val;
+out:
+	return(ret);
+}
+
+// get strings;
+
+static void
+m88e6176_get_n_strings(struct dsa_switch *ds,
+	int nr_stats, struct m88e6176_hw_stat *stats,
+	int port, uint8_t *data)
+{
+	int i;
+
+	for(i = 0; i < nr_stats; i++)
+		memcpy(data + i * ETH_GSTRING_LEN, stats[i].string, ETH_GSTRING_LEN);
+}
+
+// read all stats;
+
+static void
+m88e6176_get_n_stats(struct dsa_switch *ds,
+	int nr_stats, struct m88e6176_hw_stat *stats,
+	int port, uint64_t *data)
+{
+	struct m88e6176_priv *priv = (void *)(ds + 1);
+	struct m88e6176_hw_stat *s;
+	int ret, i;
+	u32 lo, hi;
+
+	mutex_lock(&priv->stats);
+
+	ret = m88e6176_stats_snapshot(ds, port);
+	if(ret < 0)
+		goto out;
+
+	// read each stat;
+
+	for(i = 0; i < nr_stats; i++) {
+		s = stats + i;
+		lo = hi = 0;
+		ret = m88e6176_stats_read(ds, s->reg, &lo);
+		if(s->sizeof_stat == 8)
+			m88e6176_stats_read(ds, s->reg + 1, &hi);
+		data[i] = (((u64)hi) << 32) | lo;
+	}
+out:
+	mutex_unlock(&priv->stats);
+}
+
+#ifdef IGB_VC_DUMP_ATU
+
+// dump ATU;
+
+static int
+m88e6176_dump_atu(struct dsa_switch *ds, u16 fid)
+{
+	int ret, i;
+	unsigned int macpri;
+	unsigned int aov;
+	unsigned int mbv;
+	unsigned int miv;
+	unsigned int full;
+	unsigned int trunk;
+	unsigned int dpv;
+	unsigned int state;
+	unsigned char mac[6];
+	u16 bcast;
+
+	// program broadcast MAC addr to start from;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x0d, 0xffff);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x0e, 0xffff);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x0f, 0xffff);
+	if(ret)
+		goto out;
+
+	// set atu FID;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x01, fid);
+	if(ret)
+		goto out;
+
+	do {
+		// start atu op;
+
+		ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x0b, 0xc000);
+		if(ret)
+			goto out;
+
+		// wait for atu done;
+
+		ret = -ETIMEDOUT;
+		for(i = 0; i < 20; i++) {
+			ret = m88e6176_reg_read(ds, REG_GLOBAL, 0x0b);
+			if(ret < 0x8000)
+				break;
+		}
+		if(i >= 20)
+			goto out;
+
+		// read the atu data;
+
+		macpri = (ret >> 8) & 7;
+		aov = (ret >> 7) & 1;
+		mbv = (ret >> 6) & 1;
+		miv = (ret >> 5) & 1;
+		full = (ret >> 4) & 1;
+	
+		ret = m88e6176_reg_read(ds, REG_GLOBAL, 0x0c);
+		if(ret < 0)
+			goto out;
+
+		trunk = (ret >> 15) & 1;
+		dpv = (ret >> 4) & 0xff;
+		state = (ret >> 0) & 0xf;
+
+		bcast = 0xffff;
+
+		ret = m88e6176_reg_read(ds, REG_GLOBAL, 0x0d);
+		if(ret < 0)
+			goto out;
+		mac[0] = ret >> 8;
+		mac[1] = ret & 0xff;
+		bcast &= ret;
+
+		ret = m88e6176_reg_read(ds, REG_GLOBAL, 0x0e);
+		if(ret < 0)
+			goto out;
+		mac[2] = ret >> 8;
+		mac[3] = ret & 0xff;
+		bcast &= ret;
+
+		ret = m88e6176_reg_read(ds, REG_GLOBAL, 0x0f);
+		if(ret < 0)
+			goto out;
+		mac[4] = ret >> 8;
+		mac[5] = ret & 0xff;
+		bcast &= ret;
+
+		printk("atu fid=0x%x pri=0x%x aov=%d mbv=%d miv=%d full=%d "
+			"trunk=%d dpv=0x%x state=0x%x mac=%02x:%02x:%02x:%02x:%02x:%02x\n",
+			fid, macpri, aov, mbv, miv, full,
+			trunk, dpv, state,
+			mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+	} while(bcast != 0xffff);
+
+out:
+	printk("%s %d\n", __func__, ret);
+	return(ret);
+}
+#endif // IGB_VC_DUMP_ATU
+
+// probe for m88e6176 switch;
+
+static char *
+m88e6176_probe(struct mii_bus *bus, int sw_addr)
+{
+	struct vc_dsa_priv *priv = bus->priv;
+	struct e1000_hw *hw = priv->hw;
+
+	if(hw->phy.id == M88E6176_ID)
+		return("Marvell m88e6176");
+	return(NULL);
+}
+
+// reset the switch ports;
+// however, do not touch the cpu link;
+
+static int
+m88e6176_switch_reset(struct dsa_switch *ds)
+{
+	int i, ret;
+
+	// set all ports to disabled state;
+	// reg 0x4 switch reset doesn't really hw reset the switch;
+	// do not reset the cpu port;
+
+	for(i = 0; i < 7; i++) {
+		ret = m88e6176_reg_read(ds, REG_PORT(i), 0x04);
+		if(ret >= 0)
+			m88e6176_reg_write(ds, REG_PORT(i), 0x04, ret & 0xfffc);
+        }
+
+	// wait for tx queues to drain;
+
+	usleep_range(2000, 4000);
+
+	return(0);
+}
+
+// config priority;
+
+static int
+m88e6176_config_prio(struct dsa_switch *ds)
+{
+	int ret;
+
+	// configure the IP ToS mapping registers
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x10, 0x0000);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x11, 0x0000);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x12, 0x5555);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x13, 0x5555);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x14, 0xaaaa);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x15, 0xaaaa);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x16, 0xffff);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x17, 0xffff);
+	if(ret)
+		goto out;
+
+	// configure the IEEE 802.1p priority mapping register
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x18, 0xfa41);
+out:
+	return(ret);
+}
+
+// setup globals;
+
+static int
+m88e6176_setup_global(struct dsa_switch *ds)
+{
+	int ret, i;
+
+	// bit 14 was PE (PPU enable) on m88e6165;
+	// it must be set, otherwise PHY regs are inaccessible;
+	// don't discard packets with excessive collisions;
+	// mask all interrupts;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x04, 0x4000);
+	if(ret)
+		goto out;
+
+	// set the default address aging time to 5 minutes;
+	// enable address learn messages to be sent to all message ports;
+	// configure the priority mapping registers;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x0a, 0x0149);
+	if(ret)
+		goto out;
+        ret = m88e6176_config_prio(ds);
+        if(ret < 0)
+		goto out;
+
+	// configure the upstream port as the port to which
+	// ingress and egress monitor frames are to be sent;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x1a, (dsa_upstream_port(ds) * 0x1110));
+	if(ret)
+		goto out;
+
+	// disable remote management;
+	// set the switch's DSA device number.
+
+        ret = m88e6176_reg_write(ds, REG_GLOBAL, 0x1c, ds->index & 0x1f);
+	if(ret)
+		goto out;
+
+	// send all frames with destination addresses matching
+	// 01:80:c2:00:00:2x to the CPU port;
+	// 01:80:c2:00:00:0x to the CPU port;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x02, 0xffff);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x03, 0xffff);
+	if(ret)
+		goto out;
+
+	// disable the loopback filter;
+	// disable flow control messages;
+	// disable flood broadcast override;
+	// disable removing of provider tags;
+	// disable ATU age violation interrupts;
+	// disable tag flow control;
+	// force flow control priority to the highest;
+	// send all special multicast frames to the CPU at the highest priority;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x05, 0x00ff);
+	if(ret)
+		goto out;
+
+	// program the DSA routing table;
+
+	for(i = 0; i < 32; i++) {
+		int nexthop = 0x1f;
+
+		if((i != ds->index) && (i < ds->dst->pd->nr_chips))
+			nexthop = ds->pd->rtable[i] & 0x1f;
+		ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x06, 0x8000 | (i << 8) | nexthop);
+		if(ret)
+			goto out;
+	}
+
+	// clear all trunk masks;
+
+	for(i = 0; i < 8; i++) {
+		ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x07, 0x8000 | (i << 12) | 0xff);
+		if(ret)
+			goto out;
+	}
+
+	// clear all trunk mappings;
+
+	for(i = 0; i < 16; i++) {
+		ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x08, 0x8000 | (i << 11));
+		if(ret)
+			goto out;
+	}
+
+	// disable ingress rate limiting by resetting all ingress
+	// rate limit registers to their initial state;
+
+	for(i = 0; i < 7; i++) {
+		ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x09, 0x9000 | (i << 8));
+		if(ret)
+			goto out;
+	}
+
+	// initialise cross-chip port VLAN table to reset defaults;
+
+	ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x0b, 0x9000);
+	if(ret)
+		goto out;
+
+	// clear the priority override table;
+
+	for(i = 0; i < 16; i++) {
+		ret = m88e6176_reg_write(ds, REG_GLOBAL2, 0x0f, 0x8000 | (i << 8));
+		if(ret)
+			goto out;
+	}
+out:
+	return(ret);
+}
+
+// setup single port;
+
+static int
+m88e6176_setup_port(struct dsa_switch *ds, int p)
+{
+	int ret = 0;
+	int addr = REG_PORT(p);
+	u16 val;
+
+	// do not enable port if not in switch config;
+
+	val = ds->phys_port_mask | (1 << dsa_upstream_port(ds));
+	if( !(val & (1 << p)))
+		goto out;
+
+	// don't force link, speed, duplex or flow control state on ports;
+	// but force the CPU port and all DSA ports to 1000 Mb/s full duplex;
+
+	ret = m88e6176_reg_write(ds, addr, 0x01, 0x000f);
+	if(ret)
+		goto out;
+
+	// do not limit the period of time that this port can be
+	// paused for by the remote end or the period of time that
+	// this port can pause the remote end.
+
+	ret = m88e6176_reg_write(ds, addr, 0x02, 0x0000);
+	if(ret)
+		goto out;
+
+	// disable drop-on-unlock, drop-on-lock;
+	// disable header mode;
+	// enable IGMP/MLD snooping;
+	// disable VLAN tunneling;
+	// determine priority by looking at 802.1p and IP priority fields
+	// (IP prio has precedence), and set STP state to forwarding;
+
+	// if this is the CPU link, use DSA or EDSA tagging;
+	// if this is a link to another switch, use DSA tagging mode;
+	// if this is the upstream port for this switch,
+	// then enable forwarding of unknown unicasts and multicasts.
+
+	val = 0x0433;
+	if(dsa_is_cpu_port(ds, p)) {
+		if (ds->dst->tag_protocol == htons(ETH_P_EDSA))
+			val |= 0x3300;
+		else
+			val |= 0x0100;
+	}
+	if(ds->dsa_port_mask & (1 << p))
+		val |= 0x0100;
+	if(p == dsa_upstream_port(ds))
+		val |= 0x000c;
+	ret = m88e6176_reg_write(ds, addr, 0x04, val);
+	if(ret)
+		goto out;
+
+	// disable trunking;
+	// if this is the CPU port, enable learn messages to be sent to this port;
+	// set FID[11:4] = 0;
+
+	val = dsa_is_cpu_port(ds, p)? 0x8000 : 0x0000;
+	ret = m88e6176_reg_write(ds, addr, 0x05, val);
+	if(ret)
+		goto out;
+
+	// port based VLAN map;
+	// all ports use same address database;
+	// allow the CPU port to talk to each of the 'real' ports;
+	// allow each of the 'real' ports to talk to each other and the upstream port;
+	// set FID[3:0] = 0;
+
+	val = ds->phys_port_mask;
+	if( !dsa_is_cpu_port(ds, p)) {
+		val |= 1 << dsa_upstream_port(ds);
+		val &= ~(1 << p);
+	}
+	ret = m88e6176_reg_write(ds, addr, 0x06, val);
+	if(ret)
+		goto out;
+
+	// don't set a default VLAN id;
+	// set the default packet priority to zero;
+
+	ret = m88e6176_reg_write(ds, addr, 0x07, 0x0000);
+	if(ret)
+		goto out;
+
+	// don't force a good FCS;
+	// set the maximum frame size to 10240 bytes;
+	// don't let the switch add or strip 802.1q tags;
+	// don't discard tagged or untagged frames on this port;
+	// do a destination address lookup on all received packets as usual;
+	// disable ARP mirroring and don't send a copy of all
+	// transmitted/received frames on this port to the CPU;
+
+	ret = m88e6176_reg_write(ds, addr, 0x08, 0x2080);
+	if(ret)
+		goto out;
+
+	// disable egress rate control;
+
+	ret = m88e6176_reg_write(ds, addr, 0x09, 0x0001);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, addr, 0x0a, 0x0000);
+	if(ret)
+		goto out;
+
+	// port association vector;
+	// when learning source addresses of packets, add the address
+	// to the address database using a port bitmap that has only the bit
+	// for this port set and the other bits clear;
+
+	ret = m88e6176_reg_write(ds, addr, 0x0b, 1 << p);
+	if(ret)
+		goto out;
+
+	// port ATU control: disable limiting the number of address
+	// database entries that this port is allowed to use;
+
+	ret = m88e6176_reg_write(ds, addr, 0x0c, 0x0000);
+	if(ret)
+		goto out;
+
+	// disable DA, SA and VTU priority override;
+
+	ret = m88e6176_reg_write(ds, addr, 0x0d, 0x0000);
+	if(ret)
+		goto out;
+
+	// use the DSA ethertype value;
+
+	ret = m88e6176_reg_write(ds, addr, 0x0f, ETH_P_EDSA);
+	if(ret)
+		goto out;
+
+	// use an identity 802.1p prio -> switch prio mapping;
+
+	ret = m88e6176_reg_write(ds, addr, 0x18, 0x3210);
+	if(ret)
+		goto out;
+	ret = m88e6176_reg_write(ds, addr, 0x19, 0x7654);
+	if(ret)
+		goto out;
+
+out:
+	return(0);
+}
+
+// setup switch;
+
+static int
+m88e6176_setup(struct dsa_switch *ds)
+{
+	struct m88e6176_priv *priv = (void *)(ds + 1);
+	int ret, i;
+
+	mutex_init(&priv->stats);
+
+	ret = m88e6176_switch_reset(ds);
+	if(ret < 0)
+		goto out;
+
+	ret = m88e6176_setup_global(ds);
+	if(ret < 0)
+		goto out;
+
+	for(i = 0; i < 7; i++) {
+		ret = m88e6176_setup_port(ds, i);
+		if(ret < 0)
+			goto out;
+	}
+out:
+	return(ret);
+}
+
+// hardware stats;
+
+static struct m88e6176_hw_stat m88e6176_hw_stats[] = {
+	{ "in_good_octets", 8, 0x00, },
+	{ "in_bad_octets", 4, 0x02, },
+	{ "in_unicast", 4, 0x04, },
+	{ "in_broadcasts", 4, 0x06, },
+	{ "in_multicasts", 4, 0x07, },
+	{ "in_pause", 4, 0x16, },
+	{ "in_undersize", 4, 0x18, },
+	{ "in_fragments", 4, 0x19, },
+	{ "in_oversize", 4, 0x1a, },
+	{ "in_jabber", 4, 0x1b, },
+	{ "in_rx_error", 4, 0x1c, },
+	{ "in_fcs_error", 4, 0x1d, },
+	{ "out_octets", 8, 0x0e, },
+	{ "out_unicast", 4, 0x10, },
+	{ "out_broadcasts", 4, 0x13, },
+	{ "out_multicasts", 4, 0x12, },
+	{ "out_pause", 4, 0x15, },
+	{ "excessive", 4, 0x11, },
+	{ "collisions", 4, 0x1e, },
+	{ "deferred", 4, 0x05, },
+	{ "single", 4, 0x14, },
+	{ "multiple", 4, 0x17, },
+	{ "out_fcs_error", 4, 0x03, },
+	{ "late", 4, 0x1f, },
+	{ "hist_64bytes", 4, 0x08, },
+	{ "hist_65_127bytes", 4, 0x09, },
+	{ "hist_128_255bytes", 4, 0x0a, },
+	{ "hist_256_511bytes", 4, 0x0b, },
+	{ "hist_512_1023bytes", 4, 0x0c, },
+	{ "hist_1024_max_bytes", 4, 0x0d, },
+};
+
+static void
+m88e6176_get_strings(struct dsa_switch *ds, int port, uint8_t *data)
+{
+	m88e6176_get_n_strings(ds,
+		ARRAY_SIZE(m88e6176_hw_stats),
+		m88e6176_hw_stats, port, data);
+}
+
+static void
+m88e6176_get_stats(struct dsa_switch *ds, int port, uint64_t *data)
+{
+	m88e6176_get_n_stats(ds,
+		ARRAY_SIZE(m88e6176_hw_stats),
+		m88e6176_hw_stats, port, data);
+}
+
+// get number of hw stats;
+
+static int
+m88e6176_get_sset_count(struct dsa_switch *ds)
+{
+	return(ARRAY_SIZE(m88e6176_hw_stats));
+}
+
+// dsa switch driver;
+
+struct dsa_switch_driver m88e6176_switch_driver = {
+	.tag_protocol      = cpu_to_be16(ETH_P_EDSA),
+	.priv_size         = sizeof(struct m88e6176_priv),
+	.probe             = m88e6176_probe,
+	.setup             = m88e6176_setup,
+	.set_addr          = m88e6176_set_addr,
+	.phy_read          = m88e6176_phy_read,
+	.phy_write         = m88e6176_phy_write,
+	.poll_link         = m88e6176_poll_link,
+	.get_strings       = m88e6176_get_strings,
+	.get_ethtool_stats = m88e6176_get_stats,
+	.get_sset_count    = m88e6176_get_sset_count,
+};
+
+// dsa mdio read;
+
+static int
+igb_vc_dsa_read(struct mii_bus *bus, int addr, int reg)
+{
+	struct vc_dsa_priv *priv = bus->priv;
+	struct e1000_hw *hw = priv->hw;
+	u16 data;
+	int ret;
+
+	ret = igb_vc_mdio_read(hw, (addr << 5) | reg, &data);
+	//printk("%s: %d phy %d reg %d data 0x%x\n", __func__, ret, addr, reg, data);
+	return(ret? ret : data);
+}
+
+// dsa mdio write;
+
+static int
+igb_vc_dsa_write(struct mii_bus *bus, int addr, int reg, u16 val)
+{
+	struct vc_dsa_priv *priv = bus->priv;
+	struct e1000_hw *hw = priv->hw;
+	int ret;
+
+	ret = igb_vc_mdio_write(hw, (addr << 5) | reg, val);
+	//printk("%s: %d phy %d reg %d data 0x%x\n", __func__, ret, addr, reg, val);
+	return(ret);
+}
+
+// module param to disable dsa;
+
+static int dsa = 0;
+module_param(dsa, int, 0);
+MODULE_PARM_DESC(dsa, "Enable DSA on switch.");
+
+// init dsa interface;
+
+s32
+igb_vc_dsa_init(struct igb_adapter *adapter)
+{
+	struct e1000_hw *hw = &adapter->hw;
+	struct net_device *netdev = adapter->netdev;
+	struct mii_bus *bus;
+	struct vc_dsa_priv *priv;
+	struct platform_device *pdev;
+	s32 ret;
+	int i;
+
+	if( !dsa)
+		return(0);
+	if(hw->bus.func != IGB_VC_DSA_BUS_FUNC)
+		return(0);
+
+	// allocate and register mdio bus;
+
+	bus = mdiobus_alloc_size(sizeof(struct vc_dsa_priv));
+	if( !bus)
+		return(-ENOMEM);
+
+	adapter->mii_dsa = bus;
+	priv = bus->priv;
+	priv->hw = hw;
+
+	pdev = &priv->pdev;
+	pdev->name = VC_DSA;
+	pdev->id = 0;
+	pdev->num_resources = 0;
+	pdev->dev.platform_data = &vc_switch_data;
+
+	bus->name = "mdio-dsa";
+	bus->phy_mask = ~0;
+	bus->irq = priv->irqs;
+	bus->parent = &netdev->dev;
+
+	bus->read = igb_vc_dsa_read;
+	bus->write = igb_vc_dsa_write;
+
+	for(i = 0; i < PHY_MAX_ADDR; i++) {
+		if( !bus->irq[i])
+			bus->irq[i] = PHY_POLL;
+	}
+	snprintf(bus->id, MII_BUS_ID_SIZE, VC_NAME);
+
+	ret = mdiobus_register(bus);
+	if(ret < 0)
+		goto fail_mdio_reg;
+
+	// register dsa switch;
+
+	register_switch_driver(&m88e6176_switch_driver);
+
+	vc_switch_data.netdev = &netdev->dev;
+	vc_switch.mii_bus = &bus->dev;
+	ret = platform_device_register(pdev);
+	if(ret < 0)
+		goto fail_dsa_reg;
+
+	return(0);
+
+fail_dsa_reg:
+	mdiobus_unregister(bus);
+fail_mdio_reg:
+	mdiobus_free(bus);
+	return(ret);
+}
+
+// free dsa interface;
+
+void
+igb_vc_dsa_exit(struct igb_adapter *adapter)
+{
+	struct mii_bus *bus = adapter->mii_dsa;
+	struct vc_dsa_priv *priv;
+
+	if( !dsa)
+		return;
+	if( !bus)
+		return;
+
+	priv = bus->priv;
+
+	platform_device_unregister(&priv->pdev);
+	unregister_switch_driver(&m88e6176_switch_driver);
+
+	mdiobus_unregister(bus);
+	mdiobus_free(bus);
+}
+
+
--- a/drivers/net/ethernet/intel/igb/igb.h
+++ b/drivers/net/ethernet/intel/igb/igb.h
@@ -450,6 +450,8 @@
 	u8 rss_indir_tbl[IGB_RETA_SIZE];
 
 	unsigned long link_check_timeout;
+
+	struct mii_bus *mii_dsa;
 };
 
 #define IGB_FLAG_HAS_MSI		(1 << 0)
--- a/include/uapi/linux/if_ether.h
+++ b/include/uapi/linux/if_ether.h
@@ -34,6 +34,7 @@
 #define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
 #define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
 #define ETH_FCS_LEN	4		/* Octets in the FCS		 */
+#define ETH_EDSA_LEN	8		// ethertype EDSA tag;
 
 /*
  *	These are the defined Ethernet Protocol ID's.
