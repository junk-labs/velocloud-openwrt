Fix for bug #11940. 

When init launches procd, it first unmounts and remounts /dev in
plug/coldplug.c, and then launches a ubusd process, and udevtrigger, to
walk the /sys/devices tree again, this time creating hotplug add events
for all devices.

"/dev/null" is one of these (/sys/devices/virtual/mem/null), so it takes
some time to get created.  On smaller boxes, it works anyway, but on the
edge1000, which has 1204 devices (of which 'null' is the 980th device),
/dev/null isn't created for a long time. In the meantime, _something_
gets triggered by the hotplug scripts that attempts to write to /dev/null,
so it ends up creating a plain file called /dev/null.

The fix is to explicitly create /dev/null immediately after remounting
/dev, before anything can run that might want to write to it.

Also fixed a similar goof in initd/early.c, which had _two_ errors: it
tries to create /dev/null first from a device walk using permission 0600,
and then (just in case?) it has a mknod, with the wrong permission bits
(ordinary file instead of char special), which just gives an error. Fix
this, too, so that mknod of /dev/null with the right permissions happens
first before doing a device walk.

--- a/plug/coldplug.c	2015-10-25 18:41:05.000000000 -0700
+++ a/plug/coldplug.c	2016-04-15 14:24:06.740958742 -0700
@@ -47,6 +47,7 @@
 	mount("tmpfs", "/dev", "tmpfs", 0, "mode=0755,size=512K");
 	symlink("/tmp/shm", "/dev/shm");
 	mkdir("/dev/pts", 0755);
+	mknod("/dev/null", (S_IFCHR|0666), makedev(1, 3));
 	umask(oldumask);
 	mount("devpts", "/dev/pts", "devpts", 0, 0);
 	udevtrigger.cb = udevtrigger_complete;
--- a/initd/early.c	2016-04-15 14:44:37.433029571 -0700
+++ b/initd/early.c	2016-04-15 14:44:56.072183848 -0700
@@ -26,8 +26,8 @@
 static void
 early_dev(void)
 {
+	mknod("/dev/null", (S_IFCHR|0666), makedev(1, 3));
 	mkdev("*", 0600);
-	mknod("/dev/null", 0666, makedev(1, 3));
 }
 
 static void
