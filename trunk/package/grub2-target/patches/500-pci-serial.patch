Index: grub-core/Makefile.core.def
===================================================================
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -1554,6 +1554,7 @@
   name = serial;
   common = term/serial.c;
   x86 = term/ns8250.c;
+  x86 = term/pci-serial.c;
   ieee1275 = term/ieee1275/serial.c;
   efi = term/efi/serial.c;
 
Index: include/grub/pci.h
===================================================================
--- a/include/grub/pci.h
+++ b/include/grub/pci.h
@@ -99,6 +99,12 @@
   };
 
 
+#define  GRUB_PCI_BDF(b,d,f)           ((b << 8) | (d << 3) | f)
+
+#define  GRUB_PCI_VENDOR(id)           (id & 0xffff)
+#define  GRUB_PCI_DEVICE(id)           ((id >> 16) & 0xffff)
+#define  GRUB_PCI_DEVICE_CLASS(c)      ((c >> 16) | ((c >> 8) & 0xff))
+
 typedef grub_uint32_t grub_pci_id_t;
 
 #ifdef GRUB_MACHINE_EMU
Index: include/grub/serial.h
===================================================================
--- a/include/grub/serial.h
+++ b/include/grub/serial.h
@@ -43,6 +43,9 @@
   void (*fini) (struct grub_serial_port *port);
 };
 
+/* Default base baud */
+#define UART_BASE_BAUD         115200
+
 /* The type of parity.  */
 typedef enum
   {
@@ -83,6 +86,7 @@
   {
 #if defined(__mips__) || defined (__i386__) || defined (__x86_64__)
     grub_port_t port;
+	grub_uint32_t baud_clk;
 #endif
     struct
     {
@@ -160,6 +164,7 @@
 }
 
 #if defined(__mips__) || defined (__i386__) || defined (__x86_64__)
+void grub_pci_serial_init (void);
 void grub_ns8250_init (void);
 char *grub_serial_ns8250_add_port (grub_port_t port);
 #endif
Index: grub-core/term/serial.c
===================================================================
--- a/grub-core/term/serial.c
+++ b/grub-core/term/serial.c
@@ -383,6 +383,7 @@
 	       sizeof (grub_serial_terminfo_input));
 
 #if !defined (GRUB_MACHINE_EMU) && !defined(GRUB_MACHINE_ARC) && (defined(__mips__) || defined (__i386__) || defined (__x86_64__))
+  grub_pci_serial_init();
   grub_ns8250_init ();
 #endif
 #ifdef GRUB_MACHINE_IEEE1275
Index: grub-core/term/pci-serial.c
===================================================================
--- a/grub-core/term/pci-serial.c
+++ b/grub-core/term/pci-serial.c
@@ -0,0 +1,396 @@
+/*
+ *  Copyright (C) 2013  Velocloud Inc
+ */
+
+#include <grub/pci.h>
+#include <grub/dl.h>
+#include <grub/misc.h>
+#include <grub/serial.h>
+//#include <grub/extcmd.h>
+//#include <grub/i18n.h>
+#include <grub/mm.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+// debug;
+
+#undef DEBUG_PCH_PHUB
+#ifdef DEBUG_PCH_PHUB
+#define D_PHUB(...) grub_printf("phub: " __VA_ARGS__)
+#else // DEBUG_PCH_PHUB
+#define D_PHUB(...)
+#endif // DEBUG_PCH_PHUB
+
+#undef DEBUG_PCH_UART
+#ifdef DEBUG_PCH_UART
+#define D_UART(...) grub_printf(__VA_ARGS__)
+#else // DEBUG_PCH_UART
+#define D_UART(...)
+#endif // DEBUG_PCH_UART
+
+// types;
+
+typedef struct pci_serial_dev pci_serial_dev_t;
+
+struct pci_serial_dev {
+	grub_uint32_t vendor_id;
+	grub_uint32_t device_id;
+	grub_uint32_t ss_vendor;
+	grub_uint32_t ss_device;
+	grub_uint32_t dev_class;
+	grub_uint32_t dev_class_mask;
+	grub_uint32_t base_baud;
+	void (*dev_config)(grub_pci_device_t dev, pci_serial_dev_t *psd);
+	const char *description;
+
+	grub_uint32_t bar[6];		// pci bars;
+	volatile void *base;		// mapped mem base;
+	grub_uint32_t io;			// io ports;
+};
+
+// pci IDs we support;
+
+#define PCI_ANY_ID ((unsigned int)(~0))
+
+#define PCI_CLASS_COMM_SERIAL          0x070000
+#define PCI_CLASS_COMM_SERIAL_16450    0x070001
+#define PCI_CLASS_COMM_SERIAL_16550    0x070002
+#define PCI_CLASS_COMM_SERIAL_16650    0x070003
+
+#define PCI_VENDOR_ID_TITAN            0x14D2
+#define PCI_DEVICE_ID_TITAN_100L       0x8010
+
+#define PCI_VENDOR_ID_NETMOS           0x9710
+#define PCI_DEVICE_ID_NETMOS_9835      0x9835
+
+#define PCI_VENDOR_ID_INTEL            0x8086
+#define PCI_DEVICE_ID_INTEL_PCH_PHUB   0x8801
+#define PCI_DEVICE_ID_INTEL_PCH_UART0  0x8811
+#define PCI_DEVICE_ID_INTEL_PCH_UART1  0x8812
+#define PCI_DEVICE_ID_INTEL_PCH_UART2  0x8813
+#define PCI_DEVICE_ID_INTEL_PCH_UART3  0x8814
+
+// phub register offsets;
+
+#define PCH_PHUB_ID_REG                         0x0000
+#define PCH_PHUB_QUEUE_PRI_VAL_REG              0x0004
+#define PCH_PHUB_RC_QUEUE_MAXSIZE_REG           0x0008
+#define PCH_PHUB_BRI_QUEUE_MAXSIZE_REG          0x000C
+#define PCH_PHUB_COMP_RESP_TIMEOUT_REG          0x0010
+#define PCH_PHUB_BUS_SLAVE_CONTROL_REG          0x0014
+#define PCH_PHUB_DEADLOCK_AVOID_TYPE_REG        0x0018
+#define PCH_PHUB_INTPIN_REG_WPERMIT_REG0        0x0020
+#define PCH_PHUB_INTPIN_REG_WPERMIT_REG1        0x0024
+#define PCH_PHUB_INTPIN_REG_WPERMIT_REG2        0x0028
+#define PCH_PHUB_INTPIN_REG_WPERMIT_REG3        0x002C
+#define PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE    0x0040
+#define CLKCFG_REG_OFFSET                       0x500
+#define FUNCSEL_REG_OFFSET                      0x508
+
+// clock configuration;
+
+#define CLKCFG_CAN_50MHZ     0x12000000
+#define CLKCFG_CANCLK_MASK   0xff000000
+#define CLKCFG_UART_MASK     0x00ffffff
+
+// CM-iTC
+
+#define CLKCFG_UART_48MHZ    (1 << 16)
+#define CLKCFG_BAUDDIV       (2 << 20)
+#define CLKCFG_PLL2VCO       (8 << 9)
+#define CLKCFG_UARTCLKSEL    (1 << 18)
+
+// pch definitions;
+
+#define GRUB_PCH_ADDR_MEM_MASK	(~0xff)
+
+// pci device config handlers;
+
+static void
+pci_serial_titan(grub_pci_device_t dev, pci_serial_dev_t *psd)
+{
+#if 0
+  unsigned int port;
+
+  port = grub_pci_get_bar(bus, dev, func, 1);
+  grub_serial_add(SERIAL_PCI, GRUB_PCI_BDF(bus, dev, func), bbaud, port);
+#endif
+  return;
+}
+
+static void
+pci_serial_netmos(grub_pci_device_t dev, pci_serial_dev_t *psd)
+{
+#if 0
+  unsigned int port;
+
+  port = grub_pci_get_bar(bus, dev, func, 0);
+  grub_serial_add(SERIAL_PCI, GRUB_PCI_BDF(bus, dev, func), bbaud, port);
+#endif
+  return;
+}
+
+static void
+pci_serial_generic(grub_pci_device_t dev, pci_serial_dev_t *psd)
+{
+#if 0
+  grub_serial_add(SERIAL_PCI, GRUB_PCI_BDF(bus, dev, func), bbaud, 0);
+#endif
+  return;
+}
+
+// add pch serial port;
+// set default to 115200;
+
+static struct grub_serial_port *
+pch_serial_add_port(char *name, grub_port_t port)
+{
+	struct grub_serial_port *p;
+	struct grub_serial_config config = {
+		.speed = 115200,
+		.word_len = 8,
+		.parity = GRUB_SERIAL_PARITY_NONE,
+		.stop_bits = GRUB_SERIAL_STOP_BITS_1,
+		.base_clock = 192000000,
+	};
+
+	p = grub_malloc(sizeof (*p));
+	if( !p)
+		return(0);
+
+	p->name = name;
+	p->driver = &grub_ns8250_driver;
+	p->driver->configure(p, &config);
+	p->port = port;
+	grub_serial_register(p);  
+
+	return(p);
+}
+
+// handle pch serial port;
+
+static void
+pci_serial_pch_uart(grub_pci_device_t dev, pci_serial_dev_t *psd)
+{
+	grub_uint32_t bar;
+	struct grub_serial_port *p;
+
+	bar = psd->bar[0];
+	if(bar & GRUB_PCI_ADDR_SPACE_MEMORY)
+		return;
+	psd->io = bar & GRUB_PCI_ADDR_IO_MASK;
+
+	bar = psd->bar[1];
+	if(bar & GRUB_PCI_ADDR_SPACE_IO)
+		return;
+	psd->base = grub_pci_device_map_range(dev,
+		(bar & GRUB_PCI_ADDR_MEM_MASK), 0x10);
+
+	D_UART("%s: io %x bar 0x%x base %p\n", psd->description, psd->io, bar, psd->base);
+	p = pch_serial_add_port(psd->description, psd->io);
+	if( !p) {
+		grub_printf("%s: failed to add uart\n", psd->description);
+		return;
+	}
+	D_UART("%s: registered io %x\n", p->name, psd->io);
+}
+
+// read phub register;
+
+static inline grub_uint32_t
+pch_phub_r32(volatile void *base, grub_uint32_t regoff)
+{
+	volatile grub_uint32_t *reg = (volatile grub_uint32_t *)((grub_uint32_t)base + regoff);
+	return(*reg);
+}
+
+// rd-mod-wr phub register;
+
+static inline grub_uint32_t
+pch_phub_rmw32(volatile void *base, grub_uint32_t regoff, grub_uint32_t data, grub_uint32_t mask)
+{
+	volatile grub_uint32_t *reg = (volatile grub_uint32_t *)((grub_uint32_t)base + regoff);
+	grub_uint32_t v;
+
+	v = (*reg & ~mask) | data;
+	*reg = v;
+	return(v);
+}
+
+// eg20t pch packet hub;
+
+static void
+pci_serial_pch_phub(grub_pci_device_t dev, pci_serial_dev_t *psd)
+{
+	grub_uint32_t bar, v;
+
+	bar = psd->bar[1];
+	if(bar & GRUB_PCI_ADDR_SPACE_IO)
+		return;
+	psd->base = grub_pci_device_map_range(dev,
+		(bar & GRUB_PCH_ADDR_MEM_MASK), 0x100);
+
+	D_PHUB("bar 0x%x base %p\n", bar, psd->base);
+	D_PHUB("clk conf: 0x%x\n", pch_phub_r32(psd->base, CLKCFG_REG_OFFSET));
+
+	v = pch_phub_rmw32(psd->base, CLKCFG_REG_OFFSET,
+		CLKCFG_CAN_50MHZ,
+		CLKCFG_CANCLK_MASK);
+	D_PHUB("clk conf CAN: 0x%x\n", v);
+
+	// quirk for CM-iTC board;
+
+	v = pch_phub_rmw32(psd->base, CLKCFG_REG_OFFSET,
+		CLKCFG_UART_48MHZ | CLKCFG_BAUDDIV | CLKCFG_PLL2VCO | CLKCFG_UARTCLKSEL,
+		CLKCFG_UART_MASK);
+	D_PHUB("clk conf UART: 0x%x\n", v);
+}
+
+// table of serial port pci devices;
+
+static pci_serial_dev_t pci_serial_devs[] = {
+	// entries that must match vendor/device id, not class;
+
+	{ PCI_VENDOR_ID_TITAN, PCI_ANY_ID,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  0, 0,
+	  921600,
+	  pci_serial_titan,
+	  "titan",
+	},
+	{ PCI_VENDOR_ID_NETMOS, PCI_ANY_ID,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  0, 0,
+	  115200,
+	  pci_serial_netmos,
+	  "netmos",
+	},
+
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PCH_UART0,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  0, 0,
+	  1, //XXX
+	  pci_serial_pch_uart,
+	  "pch0",
+	},
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PCH_UART1,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  0, 0,
+	  1, //XXX
+	  pci_serial_pch_uart,
+	  "pch1",
+	},
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PCH_UART2,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  0, 0,
+	  1, //XXX
+	  pci_serial_pch_uart,
+	  "pch2",
+	},
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PCH_UART3,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  0, 0,
+	  1, //XXX
+	  pci_serial_pch_uart,
+	  "pch3",
+	},
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PCH_PHUB,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  0, 0,
+	  1, //XXX
+	  pci_serial_pch_phub,
+	  "pch phub",
+	},
+
+	// entries that must match vendor/device id, not class;
+
+	{ PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_CLASS_COMM_SERIAL << 8, 0xffffff00,
+	  115200,
+	  pci_serial_generic,
+	  "generic serial",
+	},
+	{ PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_CLASS_COMM_SERIAL_16450 << 8, 0xffffff00,
+	  115200,
+	  pci_serial_generic,
+	  "generic 16450",
+	},
+	{ PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_CLASS_COMM_SERIAL_16550 << 8, 0xffffff00,
+	  115200,
+	  pci_serial_generic,
+	  "generic 16550",
+	},
+
+	// end of table;
+	{ 0, 0,
+	  0, 0,
+	  0, 0,
+	  0,
+	  0,
+	  0,
+	},
+};
+
+// callback for each pci device;
+
+static int
+grub_pci_serial_iter(grub_pci_device_t dev, grub_pci_id_t pci_id, void *data)
+{
+	grub_uint32_t vendor_id, device_id, class;
+	grub_pci_address_t addr;
+	pci_serial_dev_t *psd;
+	void (*dev_config)(grub_pci_device_t dev, pci_serial_dev_t *psd);
+	grub_uint32_t reg;
+	int i;
+
+	vendor_id = GRUB_PCI_VENDOR(pci_id);
+	device_id = GRUB_PCI_DEVICE(pci_id);
+	addr = grub_pci_make_address(dev, GRUB_PCI_REG_CLASS);
+	class = grub_pci_read(addr);
+
+	for(psd = pci_serial_devs; (dev_config = psd->dev_config); psd++) {
+		if((psd->vendor_id != PCI_ANY_ID) && (psd->vendor_id != vendor_id))
+			continue;
+		if((psd->device_id != PCI_ANY_ID) && (psd->device_id != device_id))
+			continue;
+		if((psd->dev_class ^ class) & psd->dev_class_mask)
+			continue;
+		break;
+	}
+	if( !dev_config)
+		return(0);
+
+	grub_printf("%s: pci %02x:%02x.%x %04x:%04x %x\n",
+		psd->description,
+		grub_pci_get_bus(dev), grub_pci_get_device(dev), grub_pci_get_function(dev),
+		vendor_id, device_id, class);
+
+	// get pci bars;
+
+	reg = GRUB_PCI_REG_ADDRESS_REG0;
+	for(i = 0; i < 6; i++, reg += 4) {
+		addr = grub_pci_make_address(dev, reg);
+		psd->bar[i] = grub_pci_read(addr);
+	}
+
+	dev_config(dev, psd);
+
+	return(0);
+}
+
+// init pci-serial hardware before the regular init;
+// this includes any other pci devices that the serial port depends on,
+// such as clock, or other hardware bits;
+
+void
+grub_pci_serial_init(void)
+{
+	grub_pci_iterate(grub_pci_serial_iter, NULL);
+}
+
+
